%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{\emph{Abjad}: a model of notation}
\label{chap:a-model-of-notation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\eblettrinedbl{A}{bjad\cite{baca2011xi, trevino2013compositional} is an
open-source Python\cite{vanrossum2003ys} package} extending the Python
programming language with a computational model of music notation. Abjad allows
its users to construct scores in an object-oriented fashion and to visualize
their work as publication-quality notation at any point during the composition
process. Importantly, Abjad is not a stand-alone application and has no GUI --
no graphic user interface -- unlike many other notation- or
composition-modeling projects such as PWGL\cite{laurson2009qf,
kuuskankare2004recent}, OpenMusic\cite{assayag1999sw},
BACH\cite{agostini2013real}, and so forth. Instead, all work with Abjad is done
in the command-line, either directly in an interactive Python console session,
or by writing modules of code to be imported into one another and executed by
Python's interpreter. Nearly all of the code examples in the body of this
document are presented as part of a single interactive Python console session
simply because Python's interactive console clearly distinguishes input from
output. Lines preceded by \texttt{>>>} will be passed to Python for
interpretation. Those preceded by \texttt{...} indicate the continuation of a
incomplete language construct. All other lines are necessarily returned as
output from Python's interpreter.

\todo[inline]{\textbf{TODO:} Introduce concept of namespaces.}

\todo[inline]{\textbf{TODO:} Verify that high-level description of Abjad is
on-point.}

We can import Abjad into Python with the following incantation:

\begin{comment}
<abjad>
import abjad
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> import abjad
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Abjad is implemented as a collection of over 900 public classes and
functions spread across nearly 40 subpackages, totally almost 200,000 lines of
source code. Many of these classes and functions are available immediately
within Abjad's root \emph{namespace}.\footnote{In programming, \emph{namespaces}
represents contexts in which a particular collection of \emph{names}, or
identifiers, are grouped together, with each name referencing some code object,
such as a class, function or number. Python makes extensive use of namespaces,
treating every module -- any file containing code -- as a namespace, as well as
any class, the bodies of functions and so forth. Python's namespaces are
implemented as dictionaries, a type of data structure which maps a unique set
of keys to values. Each name in a Python namespace therefore appears only,
although multiple names may be bound to the same value.}

We can enumerate these \enquote{top-level} names by calling Python's built-in
\texttt{dir()} function on the imported \texttt{Abjad} module object. After
stripping out all \enquote{private}\footnote{ Unlike many other languages, such
as C++ or Java, Python does not enforce the concept of \enquote{public} versus
\enquote{private} objects at the language level. Any object in any namespace
can be accessed by any actor at any time. Instead, Python programmers use
naming conventions to indicate which objects represent components of public
interfaces, and which objects should be considered private, although still
accessible, implementation details.} names -- those starting with underscores
-- Abjad's top-level names can be printed to Python's interactive console:

\begin{comment}
<abjad>[text_width=105]
abjad_names = dir(abjad)
abjad_names = [x for x in abjad_names if not x.startswith('_')]
print(abjad_names)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> abjad_names = dir(abjad)
>>> abjad_names = [x for x in abjad_names if not x.startswith('_')]
>>> print(abjad_names)
['Accelerando', 'Articulation', 'Beam', 'Chord', 'Clef', 'Container', 'Context', 'Crescendo',
'Decrescendo', 'Duration', 'Dynamic', 'Fermata', 'Fraction', 'Glissando', 'Hairpin', 'KeySignature',
'Markup', 'Measure', 'MultimeasureRest', 'Multiplier', 'NamedPitch', 'Note', 'Offset', 'Rest',
'Ritardando', 'Score', 'Sequence', 'Skip', 'Slur', 'Staff', 'StaffGroup', 'Tempo', 'Tie',
'TimeSignature', 'Timespan', 'Tuplet', 'Voice', 'abctools', 'abjad_configuration', 'abjadbooktools',
'agenttools', 'attach', 'datastructuretools', 'detach', 'developerscripttools', 'documentationtools',
'durationtools', 'exceptiontools', 'f', 'graph', 'handlertools', 'indicatortools', 'inspect_',
'instrumenttools', 'ipythontools', 'iterate', 'labeltools', 'layouttools', 'lilypondfiletools',
'lilypondnametools', 'lilypondparsertools', 'markuptools', 'mathtools', 'metertools', 'mutate', 'new',
'override', 'parse', 'persist', 'pitchtools', 'play', 'quantizationtools', 'rhythmmakertools',
'rhythmtreetools', 'schemetools', 'scoretools', 'select', 'selectiontools', 'selectortools',
'sequencetools', 'set_', 'show', 'sievetools', 'spannertools', 'stringtools', 'systemtools',
'templatetools', 'timespantools', 'tonalanalysistools', 'topleveltools']
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Names beginning with uppercase letters represent classes. These
include many of the musical objects composers would likely create by hand. Most
of these classes have direct notational analogs on the page -- e.g.
\texttt{Note}, \texttt{Rest} and \texttt{Chord} --, or map to common structural
or typographic concepts in Abjad's primary typesetting engine, LilyPond, such
as \texttt{Voice}, \texttt{Markup} and \texttt{Skip}. Lowercase names ending in
the string \enquote{tools} represent additional libraries or \emph{subpackages}
within Abjad. These subpackages group together related functionality within a
common namespace. For example, Abjad's \texttt{pitchtools} subpackage contains
dozens of classes and functions solely for modeling pitch objects, collections
of those objects, and their transformations:

\begin{comment}
<abjad>[text_width=105]
pitchtools_names = dir(abjad.pitchtools)
pitchtools_names = [x for x in pitchtools_names if not x.startswith('_')]
print(pitchtools_names)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> pitchtools_names = dir(abjad.pitchtools)
>>> pitchtools_names = [x for x in pitchtools_names if not x.startswith('_')]
>>> print(pitchtools_names)
['Accidental', 'Interval', 'IntervalClass', 'IntervalClassSegment', 'IntervalClassSet',
'IntervalClassVector', 'IntervalSegment', 'IntervalSet', 'IntervalVector', 'Inversion', 'Multiplication',
'NamedInterval', 'NamedIntervalClass', 'NamedInversionEquivalentIntervalClass', 'NamedPitch',
'NamedPitchClass', 'NumberedInterval', 'NumberedIntervalClass',
'NumberedInversionEquivalentIntervalClass', 'NumberedPitch', 'NumberedPitchClass',
'NumberedPitchClassColorMap', 'Octave', 'Pitch', 'PitchArray', 'PitchArrayCell', 'PitchArrayColumn',
'PitchArrayInventory', 'PitchArrayRow', 'PitchClass', 'PitchClassSegment', 'PitchClassSet',
'PitchClassTree', 'PitchClassVector', 'PitchOperation', 'PitchRange', 'PitchRangeInventory',
'PitchSegment', 'PitchSet', 'PitchVector', 'Registration', 'RegistrationComponent',
'RegistrationInventory', 'Retrogression', 'Rotation', 'Segment', 'Set', 'StaffPosition', 'Transposition',
'TwelveToneRow', 'Vector', 'instantiate_pitch_and_interval_test_collection',
'inventory_inversion_equivalent_named_interval_classes',
'inventory_named_inversion_equivalent_interval_classes', 'iterate_named_pitch_pairs_in_expr',
'list_named_pitches_in_expr', 'list_numbered_interval_numbers_pairwise',
'list_numbered_inversion_equivalent_interval_classes_pairwise',
'list_ordered_named_pitch_pairs_from_expr_1_to_expr_2', 'list_pitch_numbers_in_expr',
'list_unordered_named_pitch_pairs_in_expr', 'set_written_pitch_of_pitched_components_in_expr',
'sort_named_pitch_carriers_in_expr', 'transpose_named_pitch_by_numbered_interval_and_respell',
'transpose_pitch_carrier_by_interval', 'transpose_pitch_class_number_to_pitch_number_neighbor',
'transpose_pitch_expr_into_pitch_range', 'transpose_pitch_number_by_octave_transposition_mapping',
'yield_all_pitch_class_sets']
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Many of these subpackages implement opinionated collections of
compositional devices, certainly useful for some composers but by no means
considered core to Abjad's notational model. For example, Abjad's
\texttt{quantizationtools} provides a rhythmic quantizer inspired by Paul
Nauert's concept of \enquote{Q-grids}\cite{nauert1997timespan},
\texttt{rhythmtreetools} parses a Lisp-like \enquote{RTM-syntax} -- which
should be familiar to anyone working with OpenMusic\cite{assayag1999sw},
PWGL\cite{laurson2009qf, kuuskankare2004recent} or Bach\cite{agostini2013real},
-- into object-oriented rhythm-tree data structures, and the
\texttt{sievetools} subpackage models Iannis Xenakis' pitch
sieves\cite{xenakis1992formalized}. Still other subpackages implement more
\enquote{objective} functionality, such as \texttt{mathtools} or
\texttt{durationtools}. Many of the remaining subpackages collect together
related musical and typographic classes and functions, e.g.
\texttt{scoretools}, \texttt{spannertools}, \texttt{markuptools}, and
\texttt{indicatortools}. Others simply exist for \enquote{internal} use by
Abjad's developers, assisting in the development and maintenance of the system,
such as \texttt{abctools}, \texttt{developerscripttools},
\texttt{documentationtools} and \texttt{systemtools}.

The remaining names in Abjad's namespace represent its \enquote{top-level}
functions, including \texttt{attach()}, \texttt{detach()},
\texttt{inspect\_()}, \texttt{iterate()}, \texttt{mutate()}, \texttt{new()},
\texttt{override()}, \texttt{parse()}, \texttt{persist()}, \texttt{play()},
\texttt{select()}, and -- most importantly --
\texttt{show()}. These functions provide a powerful set of tools for
interacting with Abjad's notational objects and factories, and will be
explained in detail as we encounter each of them.

Finally, simply for the sake of brevity, this chapter -- and each subsequent
chapter -- will behave as though the contents of Abjad's namespace has been
imported into Python's global namespace:

\begin{comment}
<abjad>
from abjad import *
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> from abjad import *
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Representing objects}
\label{sec:representing-objects}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In Python, everything is an object, even integers, boolean values and
functions. Because Python is also interpreted and can be used interactively,
those objects must be representable in an interpreter session, which is
necessarily textual. An object's textual, or \emph{string}, representation can
take a variety of forms, and that same object may even specify explicitly how
it should be represented textually, just as it might specify how it should
behave in relation to such operations as addition, multiplication, or
iteration.

Python classes often specify their behavior in terms of \emph{protocols}, sets
of methods which explain the kinds of behaviors a class is able to engage in.
This explanation takes place when a class implements or overrides
\enquote{dunder} methods -- double-underscore methods -- such as
\texttt{\_\_repr\_\_()} which provides an object's \emph{interpreter
representation} in cooperation with Python's built-in \texttt{repr()} function,
and \texttt{\_\_str\_\_()} which provides an object's string representation in
cooperation with Python's built-in \texttt{str()} function. By overriding these
dunder methods, a class may specify its own version of string or interpreter
representation behavior. Like public and private names, Python protocols are
also established by convention rather than enforced at the language level, in
contrast to similar mechanisms in other languages such as Java's interfaces.

For example, a simple \texttt{Foo} class, which overrides neither
\texttt{\_\_str\_\_()} nor \texttt{\_\_repr\_\_()} may be defined and
instantiated:

\begin{comment}
<abjad>
class Foo(object):
    pass

foo = Foo()
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> class Foo(object):
...     pass
...
>>> foo = Foo()
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent When printed to the terminal, cast as a string, and represented,
Python's default object representation is used, giving the module and name of
the class as well as its memory location. Note that when calling Python's
\texttt{print()} function on an object, that object is converted to a string
and then printed to the console, resulting in text without quotation marks:

\begin{comment}
<abjad>
print(foo)
repr(foo)
str(foo)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> print(foo)
<__main__.Foo object at 0x103ae6190>
\end{minted}
\begin{minted}{python}
>>> repr(foo)
'<__main__.Foo object at 0x103ae6190>'
\end{minted}
\begin{minted}{python}
>>> str(foo)
'<__main__.Foo object at 0x103ae6190>'
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Defining a new class, \texttt{Foo2}, which overrides both string and
interpreter representation provides customized output. Note that printing the
\texttt{Foo2} instance relies on its string representation, rather than its
interpreter representation, while simply referencing the instantiated
\texttt{Foo2} object uses its interpreter representation -- its \enquote{repr}:

\begin{comment}
<abjad>
class Foo2(object):
    def __repr__(self):
        return '<I am Foo2>'
    def __str__(self):
        return 'foofoo'

foo2 = Foo2()
foo2
print(foo2)
repr(foo2)
str(foo2)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> class Foo2(object):
...     def __repr__(self):
...         return '<I am Foo2>'
...     def __str__(self):
...         return 'foofoo'
...
>>> foo2 = Foo2()
>>> foo2
<I am Foo2>
\end{minted}
\begin{minted}{python}
>>> print(foo2)
foofoo
\end{minted}
\begin{minted}{python}
>>> repr(foo2)
'<I am Foo2>'
\end{minted}
\begin{minted}{python}
>>> str(foo2)
'foofoo'
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Defining a third version of \texttt{Foo} with an overridden
\texttt{\_\_format\_\_()} method allows for creating alternate string
representations. By calling Python's built-in \texttt{format()} function on a
\texttt{Foo3} instance, either the normal string representation or a
\enquote{special} representation can be created. This formatting behavior can
also be extended to support an arbitrary number of format specifications:

\begin{comment}
<abjad>
class Foo3(object):
    def __format__(self, format_specification=''):
        if format_specification == 'special':
            return '~~~ special foo format ~~~~'
        return str(self)
    def __repr__(self):
        return '<I am Foo3>'
    def __str__(self):
        return 'foofoofoo'

foo3 = Foo3()
foo3
print(foo3)
repr(foo3)
str(foo3)
format(foo3)
format(foo3, 'special')
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> class Foo3(object):
...     def __format__(self, format_specification=''):
...         if format_specification == 'special':
...             return '~~~ special foo format ~~~~'
...         return str(self)
...     def __repr__(self):
...         return '<I am Foo3>'
...     def __str__(self):
...         return 'foofoofoo'
...
>>> foo3 = Foo3()
>>> foo3
<I am Foo3>
\end{minted}
\begin{minted}{python}
>>> print(foo3)
foofoofoo
\end{minted}
\begin{minted}{python}
>>> repr(foo3)
'<I am Foo3>'
\end{minted}
\begin{minted}{python}
>>> str(foo3)
'foofoofoo'
\end{minted}
\begin{minted}{python}
>>> format(foo3)
'foofoofoo'
\end{minted}
\begin{minted}{python}
>>> format(foo3, 'special')
'~~~ special foo format ~~~~'
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Many Abjad objects have multiple possible string representations. For
example, a \texttt{Note} object can be represented by its normal interpreter
representation, as a LilyPond string, or by its \emph{storage format} -- a more
verbose, potentially multi-line string representation generally used when
persisting complex objects to disk.

\begin{comment}
<abjad>
note = Note(NamedPitch("g'"), Duration(3, 4))
note
print(repr(note))
print(note)
print(str(note))
print(format(note))
print(format(note, 'lilypond'))
print(format(note, 'storage'))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> note = Note(NamedPitch("g'"), Duration(3, 4))
>>> note
Note("g'2.")
\end{minted}
\begin{minted}{python}
>>> print(repr(note))
Note("g'2.")
\end{minted}
\begin{minted}{python}
>>> print(note)
g'2.
\end{minted}
\begin{minted}{python}
>>> print(str(note))
g'2.
\end{minted}
\begin{minted}{python}
>>> print(format(note))
g'2.
\end{minted}
\begin{minted}{python}
>>> print(format(note, 'lilypond'))
g'2.
\end{minted}
\begin{minted}{python}
>>> print(format(note, 'storage'))
scoretools.Note("g'2.")
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent For some Abjad classes -- especially those representing glyphs in
music notation -- their default string format is their LilyPond string
representation. Other classes -- especially Abjad's various highly-configurable
notation factory classes -- default their string format to their storage
format, allowing for complex but still human-readable interpreter output. The
idiom \mintinline{python}{print(format(...))} is used extensively throughout
this document -- especially in later chapters -- to quickly display these
multi-line storage formats:

\begin{comment}
<abjad>
rhythm_maker = rhythmmakertools.TaleaRhythmMaker(
    talea=rhythmmakertools.Talea([1, 2, 3], 16),
    extra_counts_per_division=(1, 0, 2, 1, 0),
    output_masks=[
        rhythmmakertools.SustainMask([1], 3),
        rhythmmakertools.SilenceMask([-1]),
        rhythmmakertools.NullMask([0]),
        ],
    tie_specifier=rhythmmakertools.TieSpecifier(
        tie_across_divisions=True,
        ),
    )
print(format(rhythm_maker))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> rhythm_maker = rhythmmakertools.TaleaRhythmMaker(
...     talea=rhythmmakertools.Talea([1, 2, 3], 16),
...     extra_counts_per_division=(1, 0, 2, 1, 0),
...     output_masks=[
...         rhythmmakertools.SustainMask([1], 3),
...         rhythmmakertools.SilenceMask([-1]),
...         rhythmmakertools.NullMask([0]),
...         ],
...     tie_specifier=rhythmmakertools.TieSpecifier(
...         tie_across_divisions=True,
...         ),
...     )
>>> print(format(rhythm_maker))
rhythmmakertools.TaleaRhythmMaker(
    talea=rhythmmakertools.Talea(
        counts=(1, 2, 3),
        denominator=16,
        ),
    extra_counts_per_division=(1, 0, 2, 1, 0),
    output_masks=rhythmmakertools.BooleanPatternInventory(
        (
            rhythmmakertools.SustainMask(
                indices=(1,),
                invert=True,
                ),
            rhythmmakertools.SilenceMask(
                indices=(-1,),
                ),
            rhythmmakertools.NullMask(
                indices=(0,),
                ),
            )
        ),
    tie_specifier=rhythmmakertools.TieSpecifier(
        tie_across_divisions=True,
        ),
    )
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Finally, in the spirit of Python's protocols and dunder conventions,
Abjad provides its own \emph{illustration protocol} and corresponding
\texttt{\_\_illustrate\_\_()} dunder method. This method works with Abjad's
top-level \texttt{show()} function to generate graphic realizations of
illustrable Python objects by automatically formatting those objects into
LilyPond syntax and passing the resulting input to LilyPond for typesetting.
Abjad's \texttt{show()} function will be used throughout this document to
create and display music notation and other graphic representations of the
objects discussed here:

\begin{comment}
<abjad>
show(note)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> show(note)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-5cfff2844553f774341de4a66c379061.pdf}
\end{singlespacing}
\end{abjadbookoutput}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Components}
\label{sec:components}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{comment}
-   Every component may be named.
-   components, leaves, containers (and contexts)
-   components are formattable and illustrable
-   components are mutable, while indicators are generally not
    -   likewise, durations and pitches are immutable

-   count-time components
    -   note, chord, rest, skip, container, tuplet, measure
-   non-count-time (contexts)
    -   voice, staff, staff group, score

-   leaves do not contain anything else
    -   chord do *not* contain notes
    -   chords and notes contain note heads
    -   chord and notes share a single stem
    -   this must be disambiguated from note columns

-   all containers derive their duration from their contents (with some
    exceptions, but even there a mismatch is an error)
-   written duration, prolated duration, pre-prolated duration, contents
    duration

-   One, and only one, parent per component. They *cannot* be in more than one
    container. This is both confusing, and liable to cause reference problems.
-   score hierarchy is not fixed: any node is the root, if it has no parent

-   contexts are assumed to last from the beginning to the end of the total
    timespan of the score, but in practice they may be intermittent
-   contexts may be named, allowing concatenation

-   Leaves reside at the "bottom" of the score hierarchy.

Work aspects of this into appropriate sections

-   inspect_()
-   not *inspect()*, as that would cause a name conflict with Python's inspect
    module
-   inspect(...).get_parentage()
-   inspect_(...).get_duration()
    -   in_seconds=True
-   inspect_(...).get_timespan()
    -   in_seconds=True
\end{comment}

Abjad models notated musical scores as a \emph{tree} consisting of
\emph{components}, \emph{indicators} and \emph{spanners}. All objects appearing
in a score fall into one of those three categories. The most important and most
complex of the three groups, components, make up the \emph{nodes} of the score
tree, treating the score as an acyclic directed rooted graph, or
\emph{arborescence}, rooted on a single component. All components inherit from
Abjad's \texttt{Component} class, which encapsulates logic crucial to
maintaining the correctness of the score tree, and affords behaviors common to
all component subclasses including illustration, formatting and naming. Abjad
divides score components into \emph{containers} -- those components which may
contain other other components, such as staves, voices, tuplets, measures and
so forth -- and \emph{leaves} -- those components which may contain no other
components, such as notes, chords and rests, as well as LilyPond's
multi-measure rests and non-printing typographic \emph{skips}. Additionally,
components can each be instantiated from a variety of input, from parsable
LilyPond syntax strings to parametric arguments -- both numeric and explicitly
object-modeled via pitch and duration objects. For example, we can instantiate
and illustrate a middle-C quarter note:

\begin{comment}
<abjad>
note = Note("c'4")
show(note)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> note = Note("c'4")
>>> show(note)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-c018a545d264ff34225e9a3a5babb6c1.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent a half-note rest:

\begin{comment}
<abjad>
rest = Rest((1, 2))
show(rest)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> rest = Rest((1, 2))
>>> show(rest)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-8144dc38435e18921a5d584ad635d2e3.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent and a D-minor chord:

\begin{comment}
<abjad>
chord = Chord(
    [NamedPitch("d'"), NamedPitch("f'"), NamedPitch("a'")],
    Duration(1, 4),
    )
show(chord)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> chord = Chord(
...     [NamedPitch("d'"), NamedPitch("f'"), NamedPitch("a'")],
...     Duration(1, 4),
...     )
>>> show(chord)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-fef850f162448b1e8d3c6be53e362436.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Each of the above three leaf instantiations demonstrates a different
means of creating score objects, none of which is unique to the particular
class they have been demonstrated with here. The \texttt{Note} instantiation
demonstrates creating a score object via LilyPond syntax, the rest
instantiation demonstrates creating a score object from
sequences of integers -- in this case the pair (1, 2), representing the
duration of a half-note -- and the chord instantiation demonstrates using
explicit \texttt{NamedPitch} and \texttt{Duration} objects. The latter two
instantiation techniques afford parametric approaches, while the LilyPond
syntax allows for a great degree of expressivity as score components can be
created with articulations, dynamics and other indicators already attached:

\begin{comment}
<abjad>
fancy_chord = Chord(r"<g' bf'? d''>4. -\accent -\staccato ^\markup{ \italic gently }")
show(fancy_chord)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> fancy_chord = Chord(r"<g' bf'? d''>4. -\accent -\staccato ^\markup{ \italic gently }")
>>> show(fancy_chord)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-ffbf3288650db529c52c1e9ac804f9f0.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Containers}
\label{ssec:containers}

Abjad's container classes -- measures, tuplets, voice, staves, staff groups,
scores and so forth -- implement Python's \emph{mutable sequence protocol},
allowing them to be used transparently as though they were lists. Components
can be appended, extended, or inserted into containers. Containers can also be
instantiated with lists of components to be inserted as one of their
instantiation arguments. Note in the previous notation examples that the
LilyPond output always shows a \sfrac{4}{4} time signature even though none of
the created leaves takes up a whole note's duration. LilyPond simply treats all
music as \sfrac{4}{4} unless explicitly instructed otherwise. We can make the
\sfrac{4}{4} time signature explicit by instantiating a \sfrac{4}{4} measure
object to contain the three previously-created leaf instances, with the three
leaves passed in a list as an instantiation argument to the new measure:

\begin{comment}
<abjad>
measure = Measure((4, 4), [note, rest, chord])
show(measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> measure = Measure((4, 4), [note, rest, chord])
>>> show(measure)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-cad7b59ce37e423c6cdc4729377818c7.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The measure can also be represented as a graph, clarifying the
containment:

\begin{comment}
<abjad>
graph(measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> graph(measure)
\end{minted}
\noindent\includegraphics[scale=0.4,max width=\textwidth,]{assets/graphviz-f7665c2f5353983ed9713715cfe4c3aa.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Like lists, containers can be indexed into, measured for length and
iterated over. For example, the second component contained by the measure can
be selected by subscripting the measure with the index 1:\footnote{Like most
programming languages, Python counts from zero. Therefore the \enquote{first}
item in an ordered collection is indexed by the number zero, not one.}

\begin{comment}
<abjad>
measure[1]
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> measure[1]
Rest('r2')
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent That second component -- the half-note rest -- can be replaced by
another container, a triplet:

\begin{comment}
<abjad>
outer_tuplet = Tuplet((2, 3), "a'4 b4 cs'4")
measure[1] = outer_tuplet
show(measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> outer_tuplet = Tuplet((2, 3), "a'4 b4 cs'4")
>>> measure[1] = outer_tuplet
>>> show(measure)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-f9a8a92bd9dbe5f480a4003ade9c81aa.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\begin{comment}
<abjad>
graph(measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> graph(measure)
\end{minted}
\noindent\includegraphics[scale=0.4,max width=\textwidth,]{assets/graphviz-ef4980108f4d4d2b6a033286844a469e.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Furthermore, the last two leaves in the new triplet can be replaced
by a quintuplet using Python's \emph{slice assignment} syntax. In the following
code, the text \texttt{outer\_tuplet[1:]} references the selection of
components in the original triplet starting from the second component and going
\enquote{to the end} -- effectively the second and third item, as there are
only three. That selection is then replaced by a list containing a quintuplet,
substituting the contents of one sequence of components for the contents of
another.

\begin{comment}
<abjad>
inner_tuplet = Tuplet((4, 5), "b'8 a'8. g'16 f'32 e'8..")
outer_tuplet[1:] = [inner_tuplet]
show(measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> inner_tuplet = Tuplet((4, 5), "b'8 a'8. g'16 f'32 e'8..")
>>> outer_tuplet[1:] = [inner_tuplet]
>>> show(measure)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-b783a8dad0c3003152ef1b148bc60ca8.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\begin{comment}
<abjad>
graph(measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> graph(measure)
\end{minted}
\noindent\includegraphics[scale=0.4,max width=\textwidth,]{assets/graphviz-c1957e438c0db26d032c5b430f0ccba6.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The measure can be inspected for its length by using Python's
built-in \texttt{len()} function. Note that this returns the number of
components \emph{immediately} contained by the measure -- 3 --, but not the
total number of components, total number of leaves or total duration. The
latter queries can be satisfied by other means.

\begin{comment}
<abjad>
len(measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> len(measure)
3
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Iterating over the contents of the \sfrac{4}{4} measure yields only
the top-most components in that container -- its immediate children:

\begin{comment}
<abjad>
for component in measure:
    component

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> for component in measure:
...     component
...
Note("c'4")
Tuplet(Multiplier(2, 3), "a'4 { 4/5 b'8 a'8. g'16 f'32 e'8.. }")
Chord("<d' f' a'>4")
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent To select all of the leaves of a container, recursion must be used,
as any container may contain other containers, and those in turn still more
containers. To mitigate this complexity, every container provides a
\texttt{select\_leaves()} method, which returns a selection of the bottom-most
leaf instances in the subtree rooted at that container:

\begin{comment}
<abjad>
for leaf in measure.select_leaves():
    leaf

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> for leaf in measure.select_leaves():
...     leaf
...
Note("c'4")
Note("a'4")
Note("b'8")
Note("a'8.")
Note("g'16")
Note("f'32")
Note("e'8..")
Chord("<d' f' a'>4")
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Note that Abjad's \texttt{Chord} class aggregates multiple \emph{note
heads} rather than notes. Likewise Abjad's \texttt{Note} class aggregates a
single note head. While chords implement containment in terms of note heads --
delegating to a dedicated note head inventory -- they are not themselves
"containers" in the same sense that a voice, measure or tuplet are containers.
It is important here to differentiate between the concept of a \enquote{chord}
as a single duration paired with a collection of pitches and a \enquote{chord}
as the sounding sonority at some given point in a piece spread over some number
of voices. Abjad always makes use of the former rather than the latter.

\begin{comment}
<abjad>
note_head_inventory = chord.note_heads
for note_head in note_head_inventory:
    note_head

chord.note_heads.append(NamedPitch("c''"))
show(chord)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> note_head_inventory = chord.note_heads
>>> for note_head in note_head_inventory:
...     note_head
...
NoteHead("d'")
NoteHead("f'")
NoteHead("a'")
\end{minted}
\begin{minted}{python}
>>> chord.note_heads.append(NamedPitch("c''"))
>>> show(chord)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-0419b405f12cba5bff2e20c17c72e860.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Parentage}
\label{ssec:parentage}

The container that contains a given component is called its \emph{parent}, and
the components contained in a container are known as that container's
\emph{children}. Every component may have one and only one parent container,
although a component may also have no parent -- a null parent reference. Any
component whose parent is null is necessarily the root of its own score tree.
Furthermore, no component may appear in its own \emph{proper parentage} -- the
sequence of components comprising the unique path from a given component to the
root of its tree, excepting the component itself -- as this would induce
reference cycles within the score tree.

Abjad object-models the concept of parentage explicitly as a \texttt{Parentage}
\emph{selection} class, accessible via the \emph{component inspector} which
exposes a given component's \emph{inspection interface}: a collection of
methods for accessing information about that component, many of which depend on
that component's position within the score hierarchy, including the component's
parentage or duration. An inspector can be instantiated by calling Abjad's
top-level \texttt{inspect\_()} function on a component.\footnote{Abjad uses
\texttt{inspect\_()} rather than \texttt{inspect()} as Python already provides
an \texttt{inspect} module for object introspection, and it is considered bad
practice to overwrite names of functions, classes or modules found in the
standard library such as \texttt{set} or \texttt{object}. When a name conflict
would occur, projects traditionally append an underscore to the name they wish
to use.} Consider the parentage for the first eighth note of the inner
quintuplet in the previously created measure. This eighth-note's parentage --
\emph{improper} by default -- includes itself, its immediate quintuplet parent,
its triplet grandparent and the \sfrac{4}{4} measure as its
great-grandparent:\footnote{The component summary strings in the interpreter
representations of the components in the parentage are \emph{not} valid
LilyPond syntax, but simply a concise LilyPond-like syntax.}

\begin{comment}
<abjad>
inner_b_eighth = measure[1][1][0]
inspector = inspect_(inner_b_eighth)
parentage = inspector.get_parentage()
parentage.parent
for component in parentage:
    component

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> inner_b_eighth = measure[1][1][0]
>>> inspector = inspect_(inner_b_eighth)
>>> parentage = inspector.get_parentage()
>>> parentage.parent
Tuplet(Multiplier(4, 5), "b'8 a'8. g'16 f'32 e'8..")
\end{minted}
\begin{minted}{python}
>>> for component in parentage:
...     component
...
Note("b'8")
Tuplet(Multiplier(4, 5), "b'8 a'8. g'16 f'32 e'8..")
Tuplet(Multiplier(2, 3), "a'4 { 4/5 b'8 a'8. g'16 f'32 e'8.. }")
Measure((4, 4), "c'4 { 2/3 a'4 { 4/5 b'8 a'8. g'16 f'32 e'8.. } } <d' f' a' c''>4")
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent By default, every component's parent is null, represented in Python
by the \texttt{None} object:

\begin{comment}
<abjad>
whole_note = Note("c'1")
inspect_(whole_note).get_parentage().parent is None
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> whole_note = Note("c'1")
>>> inspect_(whole_note).get_parentage().parent is None
True
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Inserting the above whole note into a container sets the whole note's
parent to that container. Additionally, the container is now aware that it
contains the whole note, demonstrating the bi-directional references inherent
to Abjad's score tree model:

\begin{comment}
<abjad>
container_one = Container()
container_one.append(whole_note)
inspect_(whole_note).get_parentage().parent is container_one
whole_note in container_one
print(format(container_one))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> container_one = Container()
>>> container_one.append(whole_note)
>>> inspect_(whole_note).get_parentage().parent is container_one
True
\end{minted}
\begin{minted}{python}
>>> whole_note in container_one
True
\end{minted}
\begin{minted}{python}
>>> print(format(container_one))
{
    c'1
}
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Inserting the same whole note into a different container removes it
from the first, demonstrating that components can only exist in one container
at a time:

\begin{comment}
<abjad>
container_two = Container()
container_two.append(whole_note)
inspect_(whole_note).get_parentage().parent is container_two
whole_note in container_two
whole_note in container_one
print(format(container_two))
print(format(container_one))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> container_two = Container()
>>> container_two.append(whole_note)
>>> inspect_(whole_note).get_parentage().parent is container_two
True
\end{minted}
\begin{minted}{python}
>>> whole_note in container_two
True
\end{minted}
\begin{minted}{python}
>>> whole_note in container_one
False
\end{minted}
\begin{minted}{python}
>>> print(format(container_two))
{
    c'1
}
\end{minted}
\begin{minted}{python}
>>> print(format(container_one))
{
}
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Likewise, while the first container can be inserted into the second,
the second container cannot be inserted back into the first. Such an
arrangement would cause the second container to become its own grandparent, and
therefore generates an error:

\begin{comment}
<abjad>[allow_exceptions]
container_two.append(container_one)
container_one.append(container_two)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> container_two.append(container_one)
>>> container_one.append(container_two)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/josiah/Development/abjad/abjad/tools/scoretools/Container.py", line 1062, in append
    self.__setitem__(slice(len(self), len(self)), [component])
  File "/Users/josiah/Development/abjad/abjad/tools/scoretools/Container.py", line 218, in __setitem__
    return self._set_item(i, expr)
  File "/Users/josiah/Development/abjad/abjad/tools/scoretools/Container.py", line 561, in _set_item
    raise ParentageError('Attempted to induce cycles.')
ParentageError: Attempted to induce cycles.
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Why should we be concerned with reference cycles? When we create
score by hand, notes -- no matter how we may have arrived at them or conceived
of them creatively -- are ultimately simply black marks on a page. However,
when working with computers, we can choose how to model musical objects. Again,
a \enquote{note} could simply exist as an amalgam of dots and lines in a
vector-graphics program, in which case it may not be possible to know where or
even what that note or any other note \emph{is} except in terms of dots and
lines -- the affordances provided by that vector-graphics editor. In that case,
there is no semantic model of music, only a typographic model devoid of
explicit musical relationships. Alternatively, we can model explicitly, in
which case notes exist as "objects" in a rich network of references. In this
latter case, certain conditions must be maintained to protect the integrity of
the reference network. Depending on the implementation, a note likely cannot be
in two places at once. That is the certainly the case in Abjad's model of
musical notation: notes can only have one parent, and cannot exist in more than
one parent. Note that these restrictions mainly derive from the fact that
notes, like other scores components, are both \emph{mutable} -- that is,
changeable after they have been instantiated, and therefore \emph{stateful} --
and possess many references to objects \enquote{outside} of themselves. In
contrast, Abjad's pitch and duration classes have no state -- they are
\emph{immutable} -- and reference no other objects. They can therefore appear
in many places within the same score. Arbitrarily many score components can
reference the same duration in memory, much as arbitrarily many objects can
reference the same integer. Such an arrangement is often referred to as a
\emph{flyweight}\cite{gamma1994design}.

\subsection{Durations}
\label{ssec:durations}

Every Abjad score component may be expressed in terms of its duration, as well
as its start offset relative to the score origin and, by extension, its
timespan -- the span of time bounded by its start offset and stop offset. Abjad
models all such duration objects as \emph{rationals}: ratios of real numbers,
e.g. \sfrac{1}{2}, \sfrac{7}{23} or \sfrac{16}{1}. This concern arises from the
realization that all durations and offsets expressible in Western common
practice notation are rational, rather than floating-point or any other
representation. Necessarily, Abjad's \texttt{Duration}, \texttt{Offset} and
\texttt{Multiplier} classes all derive from Python's
\texttt{fractions.Fraction} class. Both \texttt{Offset} and \texttt{Multiplier}
are little more than aliases to Abjad's \texttt{Duration} class. However, their
use throughout Abjad's code-base, and those projects heavily dependent upon
Abjad, such as Consort, greatly clarify compositional intent and increase the
source's legibility.

Abjad's \texttt{Duration} class extends Python's \texttt{Fraction} class with a
number of new initialization patterns and a variety of notation-specific
properties. For example, a \sfrac{7}{16} duration can be instantiated from a
numerator/denominator pair, or from a LilyPond syntax duration string:

\begin{comment}
<abjad>
Duration(7, 16)
Duration.from_lilypond_duration_string('4..')
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> Duration(7, 16)
Duration(7, 16)
\end{minted}
\begin{minted}{python}
>>> Duration.from_lilypond_duration_string('4..')
Duration(7, 16)
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Duration objects can provide information about how they should be
interpreted notationally, including how many dots or flags they would have if
used to instantiate a leaf. A \sfrac{7}{16} duration, without resorting to
tuplets or ties, might be represented in notation by a double-dotted quarter
note, thus giving a dot count of 2 and a flag count of 0:

\begin{comment}
<abjad>
Duration(7, 16).dot_count
Duration(7, 16).flag_count
Duration(7, 16).lilypond_duration_string
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> Duration(7, 16).dot_count
2
\end{minted}
\begin{minted}{python}
>>> Duration(7, 16).flag_count
0
\end{minted}
\begin{minted}{python}
>>> Duration(7, 16).lilypond_duration_string
'4..'
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent As mentioned in \autoref{ssec:parentage}, duration are immutable.
Like other immutable objects in Python -- e.g. integers and string --, they
raise errors when anything attempts to alter them in anyway:

\begin{comment}
<abjad>[allow_exceptions]
string = 'abcdefghi'
string[1:-1] = 'xyz'
Duration(3, 4).numerator = 7
Duration(1, 2).nonexistant_property = 'This will never work'
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> string = 'abcdefghi'
>>> string[1:-1] = 'xyz'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
\end{minted}
\begin{minted}{python}
>>> Duration(3, 4).numerator = 7
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: can't set attribute
\end{minted}
\begin{minted}{python}
>>> Duration(1, 2).nonexistant_property = 'This will never work'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Duration' object has no attribute 'nonexistant_property'
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Additionally, some mathematical operations between offsets and
durations provide results typed in a musically-sensible fashion. For example,
the difference between two offsets returns a duration, while a duration added
to an offset returns another offset:

\begin{comment}
<abjad>
offset_one = Offset(1, 2)
offset_two = Offset(7, 4)
offset_two - offset_one
offset_two + Duration(3, 8)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> offset_one = Offset(1, 2)
>>> offset_two = Offset(7, 4)
>>> offset_two - offset_one
Duration(5, 4)
\end{minted}
\begin{minted}{python}
>>> offset_two + Duration(3, 8)
Offset(17, 8)
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The duration of each leaf derives from the product of its
\emph{written duration} -- a duration representing the actual glyphs used in
the score as represented by some combination of note heads, stems, beams and
dots -- and their \emph{prolation} -- the cumulative product of all of the
duration multipliers of the containers in a component's proper parentage.

Consider again the measure created earlier in \autoref{ssec:containers}:

\begin{comment}
<abjad>
show(measure)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> show(measure)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-12ab406580e016c3647c6966e70bbc2f.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The B eighth-note starting the quintuplet is nested within two
different tuplets with different multipliers. While the eighth-note's parentage
object can certainly calculate its prolation automatically, we will calculate
the prolation here \enquote{by hand} in order to demonstrate the technique:

\begin{comment}
<abjad>
parentage = inspect_(inner_b_eighth).get_parentage()
parentage.prolation
by_hand_prolation = 1
for parent in parentage[1:]:
    if isinstance(parent, Tuplet):
        by_hand_prolation = by_hand_prolation * parent.multiplier

by_hand_prolation
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> parentage = inspect_(inner_b_eighth).get_parentage()
>>> parentage.prolation
Multiplier(8, 15)
\end{minted}
\begin{minted}{python}
>>> by_hand_prolation = 1
>>> for parent in parentage[1:]:
...     if isinstance(parent, Tuplet):
...         by_hand_prolation = by_hand_prolation * parent.multiplier
...
>>> by_hand_prolation
Multiplier(8, 15)
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent By multiplying each leaf's written duration by its prolation, we can
determine that leaf's actual, or \emph{prolated}, duration. Note too that this
observation conforms to the results of the inspector's \texttt{get\_duration()}
method:

\begin{comment}
<abjad>
for leaf in measure.select_leaves():
    inspector = inspect_(leaf)
    written_duration = leaf.written_duration
    prolation = inspector.get_parentage().prolation
    actual_duration = inspector.get_duration()
    string = '{!r}: {!s} * {!s} = {!s}'
    string = string.format(leaf, written_duration, prolation, actual_duration)
    print(string)

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> for leaf in measure.select_leaves():
...     inspector = inspect_(leaf)
...     written_duration = leaf.written_duration
...     prolation = inspector.get_parentage().prolation
...     actual_duration = inspector.get_duration()
...     string = '{!r}: {!s} * {!s} = {!s}'
...     string = string.format(leaf, written_duration, prolation, actual_duration)
...     print(string)
...
Note("c'4"): 1/4 * 1 = 1/4
Note("a'4"): 1/4 * 2/3 = 1/6
Note("b'8"): 1/8 * 8/15 = 1/15
Note("a'8."): 3/16 * 8/15 = 1/10
Note("g'16"): 1/16 * 8/15 = 1/30
Note("f'32"): 1/32 * 8/15 = 1/60
Note("e'8.."): 7/32 * 8/15 = 7/60
Chord("<d' f' a' c''>4"): 1/4 * 1 = 1/4
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Written durations must be \emph{assignable}. Assignability describes
the set of durations describable in Western common practice notation solely
through combining a single note head, its flags and dots, without recourse to
ties or tuplets. Any rational duration $\sfrac{n}{d}$ is considered assignable
when and only when it adheres to the form

\begin{equation}
{ 2^k * (2^u - j) \over 2^v }
\end{equation}

\noindent where $u$, $v$ and $k$ are nonnegative integers, $j \leq u$ and $j$
is either 1 or 0. Assignability guarantees that a duration's denominator is
always a positive power-of-two integer, such as 1, 2, 4, 8, 16 and so forth,
and therefore precludes durations such as $\sfrac{1}{3}$ or $\sfrac{2}{5}$.
Likewise, assignability permits numerators such as 1, 2, 3, 4, 6, 7, 8, 12, 14
and 15 but forbids 5, 9, 10, 13 and 17, as they imply ties. More elegantly, any
integer is considered assignable if its binary representation -- disregarding
any leading zeros -- does not contain the substring \enquote{01}:

\begin{comment}
<abjad>
for i in range(17):
    binary_string = mathtools.integer_to_binary_string(i)
    is_assignable = mathtools.is_assignable_integer(i)
    string = '{}: {} [{}]'.format(i, binary_string, is_assignable)
    print(string)

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> for i in range(17):
...     binary_string = mathtools.integer_to_binary_string(i)
...     is_assignable = mathtools.is_assignable_integer(i)
...     string = '{}: {} [{}]'.format(i, binary_string, is_assignable)
...     print(string)
...
0: 0 [False]
1: 1 [True]
2: 10 [True]
3: 11 [True]
4: 100 [True]
5: 101 [False]
6: 110 [True]
7: 111 [True]
8: 1000 [True]
9: 1001 [False]
10: 1010 [False]
11: 1011 [False]
12: 1100 [True]
13: 1101 [False]
14: 1110 [True]
15: 1111 [True]
16: 10000 [True]
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The duration of each container then derives from the product of its
prolation and its \emph{contents duration} -- the sum of the durations of its
children. Ultimately, all scores derive their durations from the durations of
their leaves, prolated as necessary by any tuplets. Recall that containers are
mutable. As components are added to and removed from a container, the duration
of that container and the offsets of components following the inserted or
deleted component adjust dynamically to reflect the altered structure:

\begin{comment}
<abjad>
staff = Staff("c'4 d'4 e'4 f'4")
show(staff)
inspect_(staff).get_duration()
for leaf in staff:
    offset = inspect_(leaf).get_timespan().start_offset
    print(offset, leaf)

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> staff = Staff("c'4 d'4 e'4 f'4")
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-3947a1689e36c26dfc1db5d199985257.pdf}
\begin{minted}{python}
>>> inspect_(staff).get_duration()
Duration(1, 1)
\end{minted}
\begin{minted}{python}
>>> for leaf in staff:
...     offset = inspect_(leaf).get_timespan().start_offset
...     print(offset, leaf)
...
(Offset(0, 1), Note("c'4"))
(Offset(1, 4), Note("d'4"))
(Offset(1, 2), Note("e'4"))
(Offset(3, 4), Note("f'4"))
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent After inserting an additional four quarter-notes into the staff, the
staff reports its duration as doubled, and all of the leaves -- both new and
old -- report their expected start offsets:

\begin{comment}
<abjad>
staff[2:2] = "f''4 e''4 d''4 c''4"
show(staff)
inspect_(staff).get_duration()
for leaf in staff:
    offset = inspect_(leaf).get_timespan().start_offset
    print(offset, leaf)

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> staff[2:2] = "f''4 e''4 d''4 c''4"
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-378ec9dd2a14b504935cd7108d9b08b9.pdf}
\begin{minted}{python}
>>> inspect_(staff).get_duration()
Duration(2, 1)
\end{minted}
\begin{minted}{python}
>>> for leaf in staff:
...     offset = inspect_(leaf).get_timespan().start_offset
...     print(offset, leaf)
...
(Offset(0, 1), Note("c'4"))
(Offset(1, 4), Note("d'4"))
(Offset(1, 2), Note("f''4"))
(Offset(3, 4), Note("e''4"))
(Offset(1, 1), Note("d''4"))
(Offset(5, 4), Note("c''4"))
(Offset(3, 2), Note("e'4"))
(Offset(7, 4), Note("f'4"))
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Likewise, removing the middle two of the previously inserted leaves
results in the staff reporting a decreased duration, and all leaves updating
their offsets to reflect the deletion:

\begin{comment}
<abjad>
staff[3:5] = []
show(staff)
inspect_(staff).get_duration()
for leaf in staff:
    offset = inspect_(leaf).get_timespan().start_offset
    print(offset, leaf)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> staff[3:5] = []
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-64d327db461ddb041d653c1bd1d31ee6.pdf}
\begin{minted}{python}
>>> inspect_(staff).get_duration()
Duration(3, 2)
\end{minted}
\begin{minted}{python}
>>> for leaf in staff:
...     offset = inspect_(leaf).get_timespan().start_offset
...     print(offset, leaf)
(Offset(0, 1), Note("c'4"))
(Offset(1, 4), Note("d'4"))
(Offset(1, 2), Note("f''4"))
(Offset(3, 4), Note("c''4"))
(Offset(1, 1), Note("e'4"))
(Offset(5, 4), Note("f'4"))
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Finally, multiplier objects may be attached to leaves to multiply
their duration. When attached to multi-measure rests, not only does the overall
duration of the leaf change, but LilyPond is able to generate typography
representing multiple bars of tacet music compressed together:

\begin{comment}
<abjad>
multimeasure_rest = scoretools.MultimeasureRest(1)
inspect_(multimeasure_rest).get_duration()
show(multimeasure_rest)
attach(Multiplier(4), multimeasure_rest)
inspect_(multimeasure_rest).get_duration()
show(multimeasure_rest)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> multimeasure_rest = scoretools.MultimeasureRest(1)
>>> inspect_(multimeasure_rest).get_duration()
Duration(1, 1)
\end{minted}
\begin{minted}{python}
>>> show(multimeasure_rest)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-099f7141431afa5ae3a046415764f35b.pdf}
\begin{minted}{python}
>>> attach(Multiplier(4), multimeasure_rest)
>>> inspect_(multimeasure_rest).get_duration()
Duration(4, 1)
\end{minted}
\begin{minted}{python}
>>> show(multimeasure_rest)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-a8fdc5cae1a0a9fb72680a5d18862c4e.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Named components}
\label{ssec:named-components}

Abjad's scores components may be given unique names via their \texttt{name}
property. Any named component found in the subtree of a given container may be
accessed by subscripting the container with its name, regardless of its depth
in that container.

Consider the following score, containing a piano staff grouping two staves,
each with one voice. Disregard the ugliness of the notation for the time being;
it will be cleaned up in \autoref{sec:indicators} and \autoref{sec:spanners}:

\begin{comment}
<abjad>
voice_1 = Voice(name='Voice 1')
voice_1.append(Measure((3, 4), "d'4.. b'16 af'4"))
voice_1.append(Measure((5, 4), "af'4. g'8 c''8 b'4. b'8 r16 d''16"))
upper_staff = Staff(
    [voice_1],
    name='Upper Staff',
    )
voice_2 = Voice(name='Voice 2')
voice_2.append(Measure((3, 4), "r8 c'8 r8 d8 r8 e8"))
voice_2.append(Measure((5, 4), r"r4 \times 2/3 { g4 fs4 e8 cs8 } r4. fs8"))
lower_staff = Staff(
    [voice_2],
    name='Lower Staff',
    )
staff_group = StaffGroup(
    [upper_staff, lower_staff],
    context_name='PianoStaff',
    name='Both Staves',
    )
score = Score([staff_group])
show(score)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> voice_1 = Voice(name='Voice 1')
>>> voice_1.append(Measure((3, 4), "d'4.. b'16 af'4"))
>>> voice_1.append(Measure((5, 4), "af'4. g'8 c''8 b'4. b'8 r16 d''16"))
>>> upper_staff = Staff(
...     [voice_1],
...     name='Upper Staff',
...     )
>>> voice_2 = Voice(name='Voice 2')
>>> voice_2.append(Measure((3, 4), "r8 c'8 r8 d8 r8 e8"))
>>> voice_2.append(Measure((5, 4), r"r4 \times 2/3 { g4 fs4 e8 cs8 } r4. fs8"))
>>> lower_staff = Staff(
...     [voice_2],
...     name='Lower Staff',
...     )
>>> staff_group = StaffGroup(
...     [upper_staff, lower_staff],
...     context_name='PianoStaff',
...     name='Both Staves',
...     )
>>> score = Score([staff_group])
>>> show(score)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-b1362195566865429817139f315f5f3e.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Printing the score as a LilyPond syntax string clearly shows the
nested quality of the score hierarchy. Additionally, the previously provided
names of some of the containers -- e.g. \enquote{Voice 1} and \enquote{Lower
Staff} -- also appear in the LilyPond output:

\begin{comment}
<abjad>
print(format(score))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> print(format(score))
\new Score <<
    \context PianoStaff = "Both Staves" <<
        \context Staff = "Upper Staff" {
            \context Voice = "Voice 1" {
                {
                    \time 3/4
                    d'4..
                    b'16
                    af'4
                }
                {
                    \time 5/4
                    af'4.
                    g'8
                    c''8
                    b'4.
                    b'8
                    r16
                    d''16
                }
            }
        }
        \context Staff = "Lower Staff" {
            \context Voice = "Voice 2" {
                {
                    \time 3/4
                    r8
                    c'8
                    r8
                    d8
                    r8
                    e8
                }
                {
                    \time 5/4
                    r4
                    \times 2/3 {
                        g4
                        fs4
                        e8
                        cs8
                    }
                    r4.
                    fs8
                }
            }
        }
    >>
>>
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Any of the named components within the score hierarchy can be
selected by subscripting any container in their proper parentage with their
name. For example, the voice container named \enquote{Voice 1} can be selected
by subscripting the score object with its name, even though it is not
immediately contained by the score but is in fact a \enquote{great-grandchild}
of the score:

\begin{comment}
<abjad>
score['Voice 1']
score['Voice 1'] is voice_1
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> score['Voice 1']
<Voice-"Voice 1"{2}>
\end{minted}
\begin{minted}{python}
>>> score['Voice 1'] is voice_1
True
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Note that the staff group definition above received both a
\texttt{name} and a \texttt{context\_name} keyword argument. While the various
voices and staves in the above score all appear in the LilyPond syntax output
as \texttt{\textbackslash{}context Staff = "Upper Staff"} or
\texttt{\textbackslash{}context Voice = "Voice 2"}, the staff group appears
instead as \texttt{\textbackslash{}context PianoStaff = "Both Staves"}. Its
\enquote{context name} has been substituted for where \texttt{StaffGroup} would
normally appear, allowing Abjad to specify a different LilyPond \emph{context}
for the music it contains.

Some Abjad container classes correspond to LilyPond's notion of
\emph{contexts}. These include voices, staves, staff groups and scores, but not
measures, tuplets or \enquote{bare} containers. LilyPond uses contexts during
typesetting to maintain various kinds of musical information hierarchically.
For example, LilyPond's \texttt{Staff} context maintains information about the
accidentals that have appeared so far in any voice contained by that staff as
well as the staff's current clef -- all of which is necessarily local to a
single staff --, while the \texttt{Score} context maintains more global
information, such as the current tempo and measure number. LilyPond allow
composers to define new contexts, and provides a number of specially-defined
contexts, e.g. \texttt{ChoirStaff}, \texttt{TabVoice} and \texttt{FiguredBass}.
While LilyPond's contexts may be either named or anonymous, named contexts
allow LilyPond to stitch together different sections of music into a single
continuous score, allowing different segments of a work to be defined in
different files and then concatenated together.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Indicators}
\label{sec:indicators}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Abjad's indicators include any object attached to a single score component,
such as articulations, textual markup, clefs, tempo or time signature
indications. Unlike score components and spanners, indicators do not share a
common base class. Instead, they are unified by the means by which they have
been attached to components: Abjad's top-level \texttt{attach()} function.
Indicators are generally immutable, like integers and durations. Regardless, in
being attached to a score component they do not receive a reference to that
component, allowing the same indicator to be attached to many components. Abjad
binds the indicator to the component via an \texttt{IndicatorExpression}
object, which holds the necessary references to both the indicator and the
component along with other important information about the behavior of the
attachment.

Consider a simple four note staff. A single accent articulation can be attached
to each note in the staff via \texttt{attach()}:

\begin{comment}
<abjad>
staff = Staff("c'4 d'4 e'4 f'4")
accent = Articulation('accent')
for note in staff:
    attach(accent, note)

show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> staff = Staff("c'4 d'4 e'4 f'4")
>>> accent = Articulation('accent')
>>> for note in staff:
...     attach(accent, note)
...
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-28933ab8c116701be372aeadc38a025e.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Once attached, indicators can be removed via the top-level
\texttt{detach()} function. For example, the attached accents can be detached
from the last three leaves of the above staff via the \texttt{detach()}
function:

\begin{comment}
<abjad>
for note in staff[1:]:
    detach(accent, note)

show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> for note in staff[1:]:
...     detach(accent, note)
...
(Articulation('accent'),)
(Articulation('accent'),)
(Articulation('accent'),)
\end{minted}
\begin{minted}{python}
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-712238b1f24829bf1654cbf459e3fb22.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent At this point, only the first note in the staff has anything
attached. As with durations and parentage, we can use the component inspector
to verify that this is true by testing each note for the existence of an
indicator of the class \texttt{Articulation}:

\begin{comment}
<abjad>
for note in staff:
    has_articulation = inspect_(note).has_indicator(Articulation)
    print(note, has_articulation)

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> for note in staff:
...     has_articulation = inspect_(note).has_indicator(Articulation)
...     print(note, has_articulation)
...
(Note("c'4"), True)
(Note("d'4"), False)
(Note("e'4"), False)
(Note("f'4"), False)
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Likewise, we can use the component inspector to retrieve the attached
articulation. The inspector provides two methods for retrieving indicators
attached to a single component: \texttt{get\_indicator()} and
\texttt{get\_indicators()}. The latter returns a tuple of zero or more
indicators matching any supplied class prototype, while the former returns only
one and raises an error if more or less than one indicator matching the
supplied class prototype is attached. In the case of retrieving any attached
articulations from the staff's first note -- given that there is only one
articulation attached --, both methods work perfectly.

\begin{comment}
<abjad>[allow_exceptions]
inspect_(staff[0]).get_indicators(Articulation)
inspect_(staff[0]).get_indicator(Articulation)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> inspect_(staff[0]).get_indicators(Articulation)
(Articulation('accent'),)
\end{minted}
\begin{minted}{python}
>>> inspect_(staff[0]).get_indicator(Articulation)
Articulation('accent')
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Consider again the two-staff score created earlier:

\begin{comment}
<abjad>
show(score)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> show(score)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-b1362195566865429817139f315f5f3e.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent A variety of indicators can be attached to the leaves in this score
to present a more convincing musical result, including clefs, dynamics, tempi
and articulations. Note that indicators can be attached to both leaf and
container components:

\begin{comment}
<abjad>
attach(Clef('treble'), score['Upper Staff'])
attach(Clef('bass'), score['Lower Staff'])
lower_leaves = score['Lower Staff'].select_leaves()
for i in [1, 3, 5, 12]:
    attach(Articulation('staccato'), lower_leaves[i])

attach(Tempo((1, 4), 88), score['Voice 1'][0][0])
attach(Dynamic('p'), score['Voice 1'][0][0])
attach(Dynamic('f'), score['Voice 1'][1][0])
attach(Dynamic('ppp'), score['Voice 1'][1][-1])
show(score)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> attach(Clef('treble'), score['Upper Staff'])
>>> attach(Clef('bass'), score['Lower Staff'])
>>> lower_leaves = score['Lower Staff'].select_leaves()
>>> for i in [1, 3, 5, 12]:
...     attach(Articulation('staccato'), lower_leaves[i])
...
>>> attach(Tempo((1, 4), 88), score['Voice 1'][0][0])
>>> attach(Dynamic('p'), score['Voice 1'][0][0])
>>> attach(Dynamic('f'), score['Voice 1'][1][0])
>>> attach(Dynamic('ppp'), score['Voice 1'][1][-1])
>>> show(score)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-c5f77f1a94704e8f098e761bd215d443.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Indicator scope}
\label{ssec:indicator-scope}

Abjad models how the influence of certain types of indicators persists across
components subsequent to the component they attach to via the concept of
\emph{indicator scope}. Indicator scope describes how, for example, all
components in a score are governed by one tempo from the moment that tempo
appears until the moment a different appears. Likewise, scoping describes how
all leaves in a staff are understood to be governed by the staff's clef up
until the point that that clef changes. Different indicators govern different
scopes by default. As just described, tempo indications govern the score
context, while clef, key signature and dynamics govern the staff context. An
indicator governing some component is known as that component's
\emph{effective} indicator. As with non-scoped indicators, the component
inspector can be used to examine if and what indicator of a given type is
effective for a given component.

Consider the score above, to which a variety of indicators have just been
attached. By inspecting the leaves in both staves with the component
inspector's \texttt{get\_effective()} method, we can determine what indicators
are effective for each leaf. For example, all of the leaves in the upper staff
will report that their clef is a treble clef, while all of the leaves in the
lower staff will report that theirs is a bass clef:

\begin{comment}
<abjad>
for leaf in score['Upper Staff'].select_leaves():
    clef = inspect_(leaf).get_effective(Clef)
    print(leaf, clef)

for leaf in score['Lower Staff'].select_leaves():
    clef = inspect_(leaf).get_effective(Clef)
    print(leaf, clef)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> for leaf in score['Upper Staff'].select_leaves():
...     clef = inspect_(leaf).get_effective(Clef)
...     print(leaf, clef)
...
(Note("d'4.."), Clef(name='treble'))
(Note("b'16"), Clef(name='treble'))
(Note("af'4"), Clef(name='treble'))
(Note("af'4."), Clef(name='treble'))
(Note("g'8"), Clef(name='treble'))
(Note("c''8"), Clef(name='treble'))
(Note("b'4."), Clef(name='treble'))
(Note("b'8"), Clef(name='treble'))
(Rest('r16'), Clef(name='treble'))
(Note("d''16"), Clef(name='treble'))
\end{minted}
\begin{minted}{python}
>>> for leaf in score['Lower Staff'].select_leaves():
...     clef = inspect_(leaf).get_effective(Clef)
...     print(leaf, clef)
(Rest('r8'), Clef(name='bass'))
(Note("c'8"), Clef(name='bass'))
(Rest('r8'), Clef(name='bass'))
(Note('d8'), Clef(name='bass'))
(Rest('r8'), Clef(name='bass'))
(Note('e8'), Clef(name='bass'))
(Rest('r4'), Clef(name='bass'))
(Note('g4'), Clef(name='bass'))
(Note('fs4'), Clef(name='bass'))
(Note('e8'), Clef(name='bass'))
(Note('cs8'), Clef(name='bass'))
(Rest('r4.'), Clef(name='bass'))
(Note('fs8'), Clef(name='bass'))
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent While the tempo indication is only attached to the first leaf in the
upper staff, all leaves in the entire score report that same tempo as their
effective tempo:

\begin{comment}
<abjad>
for leaf in score['Upper Staff'].select_leaves():
    tempo = inspect_(leaf).get_effective(Tempo)
    print(leaf, tempo)

for leaf in score['Lower Staff'].select_leaves():
    tempo = inspect_(leaf).get_effective(Tempo)
    print(leaf, tempo)

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> for leaf in score['Upper Staff'].select_leaves():
...     tempo = inspect_(leaf).get_effective(Tempo)
...     print(leaf, tempo)
...
(Note("d'4.."), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note("b'16"), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note("af'4"), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note("af'4."), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note("g'8"), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note("c''8"), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note("b'4."), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note("b'8"), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Rest('r16'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note("d''16"), Tempo(duration=Duration(1, 4), units_per_minute=88))
\end{minted}
\begin{minted}{python}
>>> for leaf in score['Lower Staff'].select_leaves():
...     tempo = inspect_(leaf).get_effective(Tempo)
...     print(leaf, tempo)
...
(Rest('r8'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note("c'8"), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Rest('r8'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note('d8'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Rest('r8'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note('e8'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Rest('r4'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note('g4'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note('fs4'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note('e8'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note('cs8'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Rest('r4.'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note('fs8'), Tempo(duration=Duration(1, 4), units_per_minute=88))
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent However, the dynamic indications attached to the leaves in the upper
staff are effective only for those leaves, and not for the leaves in the lower
staff:

\begin{comment}
<abjad>
for leaf in score['Upper Staff'].select_leaves():
    dynamic = inspect_(leaf).get_effective(Dynamic)
    print(leaf, dynamic)

for leaf in score['Lower Staff'].select_leaves():
    dynamic = inspect_(leaf).get_effective(Dynamic)
    print(leaf, dynamic)

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> for leaf in score['Upper Staff'].select_leaves():
...     dynamic = inspect_(leaf).get_effective(Dynamic)
...     print(leaf, dynamic)
...
(Note("d'4.."), Dynamic(name='p'))
(Note("b'16"), Dynamic(name='p'))
(Note("af'4"), Dynamic(name='p'))
(Note("af'4."), Dynamic(name='f'))
(Note("g'8"), Dynamic(name='f'))
(Note("c''8"), Dynamic(name='f'))
(Note("b'4."), Dynamic(name='f'))
(Note("b'8"), Dynamic(name='f'))
(Rest('r16'), Dynamic(name='f'))
(Note("d''16"), Dynamic(name='ppp'))
\end{minted}
\begin{minted}{python}
>>> for leaf in score['Lower Staff'].select_leaves():
...     dynamic = inspect_(leaf).get_effective(Dynamic)
...     print(leaf, dynamic)
...
(Rest('r8'), None)
(Note("c'8"), None)
(Rest('r8'), None)
(Note('d8'), None)
(Rest('r8'), None)
(Note('e8'), None)
(Rest('r4'), None)
(Note('g4'), None)
(Note('fs4'), None)
(Note('e8'), None)
(Note('cs8'), None)
(Rest('r4.'), None)
(Note('fs8'), None)
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Both the clef, tempo and dynamics inspected above made use of their
\emph{default scope} when being attached, specifying implicitly that they be
effective at either the staff or score context-level. Indicators can also be
attached with an explicitly-specified scope, overriding any default the
indicator's class might provide. By detaching the implicitly-staff-scoped
dynamics, those same dynamic indications can be reattached, explicitly scoped
for the \enquote{PianoStaff} context, allowing all leaves contained by that
piano staff -- which includes both the upper and lower staves -- to detect
their appropriate dynamic level:

\begin{comment}
<abjad>
piano_dynamic = detach(Dynamic, score['Voice 1'][0][0])[0]
forte_dynamic = detach(Dynamic, score['Voice 1'][1][0])[0]
pianississimo_dynamic = detach(Dynamic, score['Voice 1'][1][-1])[0]
attach(piano_dynamic, score['Voice 1'][0][0], scope='PianoStaff')
attach(forte_dynamic, score['Voice 1'][1][0], scope='PianoStaff')
attach(pianississimo_dynamic, score['Voice 1'][1][-1], scope='PianoStaff')
for leaf in score['Upper Staff'].select_leaves():
    dynamic = inspect_(leaf).get_effective(Dynamic)
    print(leaf, dynamic)

for leaf in score['Lower Staff'].select_leaves():
    dynamic = inspect_(leaf).get_effective(Dynamic)
    print(leaf, dynamic)

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> piano_dynamic = detach(Dynamic, score['Voice 1'][0][0])[0]
>>> forte_dynamic = detach(Dynamic, score['Voice 1'][1][0])[0]
>>> pianississimo_dynamic = detach(Dynamic, score['Voice 1'][1][-1])[0]
>>> attach(piano_dynamic, score['Voice 1'][0][0], scope='PianoStaff')
>>> attach(forte_dynamic, score['Voice 1'][1][0], scope='PianoStaff')
>>> attach(pianississimo_dynamic, score['Voice 1'][1][-1], scope='PianoStaff')
>>> for leaf in score['Upper Staff'].select_leaves():
...     dynamic = inspect_(leaf).get_effective(Dynamic)
...     print(leaf, dynamic)
...
(Note("d'4.."), Dynamic(name='p'))
(Note("b'16"), Dynamic(name='p'))
(Note("af'4"), Dynamic(name='p'))
(Note("af'4."), Dynamic(name='f'))
(Note("g'8"), Dynamic(name='f'))
(Note("c''8"), Dynamic(name='f'))
(Note("b'4."), Dynamic(name='f'))
(Note("b'8"), Dynamic(name='f'))
(Rest('r16'), Dynamic(name='f'))
(Note("d''16"), Dynamic(name='ppp'))
\end{minted}
\begin{minted}{python}
>>> for leaf in score['Lower Staff'].select_leaves():
...     dynamic = inspect_(leaf).get_effective(Dynamic)
...     print(leaf, dynamic)
...
(Rest('r8'), Dynamic(name='p'))
(Note("c'8"), Dynamic(name='p'))
(Rest('r8'), Dynamic(name='p'))
(Note('d8'), Dynamic(name='p'))
(Rest('r8'), Dynamic(name='p'))
(Note('e8'), Dynamic(name='p'))
(Rest('r4'), Dynamic(name='f'))
(Note('g4'), Dynamic(name='f'))
(Note('fs4'), Dynamic(name='f'))
(Note('e8'), Dynamic(name='f'))
(Note('cs8'), Dynamic(name='f'))
(Rest('r4.'), Dynamic(name='f'))
(Note('fs8'), Dynamic(name='f'))
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Recall the voices in the score were populated by Abjad
\texttt{Measure} objects. While LilyPond's musical model does not make use of
explicit measures, Abjad provides measure-like containers as a convenience.
When instantiated, Abjad measures attach the appropriate time signature
indication to themselves. These indicators are also scoped by default, allowing
all of the leaves contained in that measure to detect their appropriate time
signature:

\begin{comment}
<abjad>
measure_1 = score['Voice 1'][0]
measure_2 = score['Voice 1'][1]
inspect_(measure_1).get_indicator(TimeSignature)
for leaf in measure_1.select_leaves():
    time_signature = inspect_(leaf).get_effective(TimeSignature)
    print(leaf, time_signature)

inspect_(measure_2).get_indicator(TimeSignature)
for leaf in measure_2.select_leaves():
    time_signature = inspect_(leaf).get_effective(TimeSignature)
    print(leaf, time_signature)

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> measure_1 = score['Voice 1'][0]
>>> measure_2 = score['Voice 1'][1]
>>> inspect_(measure_1).get_indicator(TimeSignature)
TimeSignature((3, 4))
\end{minted}
\begin{minted}{python}
>>> for leaf in measure_1.select_leaves():
...     time_signature = inspect_(leaf).get_effective(TimeSignature)
...     print(leaf, time_signature)
...
(Note("d'4.."), TimeSignature((3, 4)))
(Note("b'16"), TimeSignature((3, 4)))
(Note("af'4"), TimeSignature((3, 4)))
\end{minted}
\begin{minted}{python}
>>> inspect_(measure_2).get_indicator(TimeSignature)
TimeSignature((5, 4))
\end{minted}
\begin{minted}{python}
>>> for leaf in measure_2.select_leaves():
...     time_signature = inspect_(leaf).get_effective(TimeSignature)
...     print(leaf, time_signature)
...
(Note("af'4."), TimeSignature((5, 4)))
(Note("g'8"), TimeSignature((5, 4)))
(Note("c''8"), TimeSignature((5, 4)))
(Note("b'4."), TimeSignature((5, 4)))
(Note("b'8"), TimeSignature((5, 4)))
(Rest('r16'), TimeSignature((5, 4)))
(Note("d''16"), TimeSignature((5, 4)))
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Annotations}
\label{ssec:annotations}

Indicators may be attached to score components as \emph{annotations},
\enquote{visible} to inspection and potentially scoped, but contributing no
formatting to a score hierarchy's LilyPond output. Additionally, any attached
indication which cannot contribute formatting is considered an implicit
annotation. Consider some of the indicators used above, such as clefs, time
signatures, dynamics and tempo indications. All of these objects can be
formatted as LilyPond syntax, and when attached to components in a score will
appear in the output if and when the score itself is formatted as LilyPond
syntax:

\begin{comment}
<abjad>
clef = Clef('bass')
print(format(clef, 'lilypond'))
time_signature = TimeSignature((5, 4))
print(format(time_signature, 'lilypond'))
dynamic = Dynamic('p')
print(format(dynamic, 'lilypond'))
tempo = Tempo((1, 4), 88)
print(format(tempo, 'lilypond'))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> clef = Clef('bass')
>>> print(format(clef, 'lilypond'))
\clef "bass"
\end{minted}
\begin{minted}{python}
>>> time_signature = TimeSignature((5, 4))
>>> print(format(time_signature, 'lilypond'))
\time 5/4
\end{minted}
\begin{minted}{python}
>>> dynamic = Dynamic('p')
>>> print(format(dynamic, 'lilypond'))
\p
\end{minted}
\begin{minted}{python}
>>> tempo = Tempo((1, 4), 88)
>>> print(format(tempo, 'lilypond'))
\tempo 4=88
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent For example, the above four indicators can be attached to the
contents of the following staff which, when formatted, shows the expected
format contributions of each indicator. Note that the staff must be wrapped in
a score container so that its tempo indication can find the appropriate
context:

\begin{comment}
<abjad>
staff = Staff("g f e d c")
attach(clef, staff)
attach(dynamic, staff)
attach(tempo, staff)
attach(time_signature, staff)
Score([staff])
print(format(staff))
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> staff = Staff("g f e d c")
>>> attach(clef, staff)
>>> attach(dynamic, staff)
>>> attach(tempo, staff)
>>> attach(time_signature, staff)
>>> Score([staff])
<Score<<1>>>
\end{minted}
\begin{minted}{python}
>>> print(format(staff))
\new Staff {
    \clef "bass"
    \tempo 4=88
    \time 5/4
    g4
    f4
    e4
    d4
    c4
}
\end{minted}
\begin{minted}{python}
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-92459f3cc246a32ad77f8f6f2552a053.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The above staff can be recreated with the indicators attached as
annotations, still effective for each leaf, but providing no format
contributions in the output. This results in rather poor notation, falling back
on LilyPond's default \sfrac{4}{4} time signature and treble clef:

\begin{comment}
<abjad>
staff = Staff("g f e d c")
attach(clef, staff, is_annotation=True)
attach(dynamic, staff, is_annotation=True)
attach(tempo, staff, is_annotation=True)
attach(time_signature, staff, is_annotation=True)
Score([staff])
print(format(staff))
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> staff = Staff("g f e d c")
>>> attach(clef, staff, is_annotation=True)
>>> attach(dynamic, staff, is_annotation=True)
>>> attach(tempo, staff, is_annotation=True)
>>> attach(time_signature, staff, is_annotation=True)
>>> Score([staff])
<Score<<1>>>
\end{minted}
\begin{minted}{python}
>>> print(format(staff))
\new Staff {
    g4
    f4
    e4
    d4
    c4
}
\end{minted}
\begin{minted}{python}
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-a55f0283cb66b704a30daf80a4471e39.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Still, the leaves in this second staff can be inspected and will all
report that various indicators attached to the staff, although annotative, are
effective for them:

\begin{comment}
<abjad>
for note in staff:
    tempo = inspect_(note).get_effective(Tempo)
    print(note, tempo)

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> for note in staff:
...     tempo = inspect_(note).get_effective(Tempo)
...     print(note, tempo)
...
(Note('g4'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note('f4'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note('e4'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note('d4'), Tempo(duration=Duration(1, 4), units_per_minute=88))
(Note('c4'), Tempo(duration=Duration(1, 4), units_per_minute=88))
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Annotation allows arbitrary objects to be attached to any score
component as a kind of metadata without directly affecting LilyPond's
typesetting, allowing other later compositional processes to inspect or react
to those annotations. Abjad provides a variety of indicator classes for this
purpose, none of which contribute any formatting, but all of which can be
attached and scoped, allowing composers to better model instrumental technique
or compositional intent. Some of these annotative indicators include
\texttt{BowContactPoint}, \texttt{IsAtSoundingPitch}, \texttt{IsUnpitched},
\texttt{StringContactPoint} and \texttt{StringTuning}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Spanners}
\label{sec:spanners}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo[inline]{\textbf{TODO:} Footnote a definition of logical voices.}

A final collection of classes, \emph{spanners}, model musical and typographic
constructs such as slurs, beams, hairpins, and glissandi which \emph{span}
across different levels of hierarchy in the score tree. Spanners attach to not
just one but potentially many components in a score tree, provided those
components are contiguous in time and occupy the same \emph{logical voice}.
Like indicators, multiple spanners can attach to the same component. Unlike
indicators, spanners are aware of the components, including the leaves, they
\emph{cover} as well as the order in which those components appear. This
awareness allows spanners to contribute formatting to a score tree's LilyPond
syntax output conditionally. The first and last leaves covered by a spanner can
be formatted specially, and the types of leaves covered by a spanner, their
durations or even any indicators attached to those leaves can be considered
during formatting, allowing spanners to make use of annotative indicators
attached to components.

Consider the following staff, which contains leaves as well as a triplet,
itself containing more leaves:

\begin{comment}
<abjad>
staff = Staff(r"c'4 \times 2/3 { c'8 e'8 g'8 } g'2")
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> staff = Staff(r"c'4 \times 2/3 { c'8 e'8 g'8 } g'2")
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-a604f46da3988b3319380e311f6a5082.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent A variety of spanners can be attached to both the leaves of the staff
as well as to the staff itself using Abjad's \texttt{attach()} function. For
example, a slur can be attached to all of the leaves of the staff -- including
those in the triplet --, a crescendo attached to the staff itself -- but not to
its leaves --, and two ties attached to the pairs of C- and G-notes which
border the bounds of the triplet:

\begin{comment}
<abjad>
slur = Slur()
crescendo = Crescendo()
tie_one = Tie()
tie_two = Tie()
leaves = staff.select_leaves()
attach(slur, leaves)
attach(crescendo, staff)
attach(tie_one, leaves[:2])
attach(tie_two, leaves[-2:])
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> slur = Slur()
>>> crescendo = Crescendo()
>>> tie_one = Tie()
>>> tie_two = Tie()
>>> leaves = staff.select_leaves()
>>> attach(slur, leaves)
>>> attach(crescendo, staff)
>>> attach(tie_one, leaves[:2])
>>> attach(tie_two, leaves[-2:])
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-1c1200b5202e55c93d3b2b20b5487ffc.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent As with indicators, the component inspector provides methods for
inspecting any spanners attached to a given component:

\begin{comment}
<abjad>
inspect_(staff[0]).get_spanners()
inspect_(staff).get_spanners()
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> inspect_(staff[0]).get_spanners()
set([Tie("c'4, c'8"), Slur("c'4, c'8, e'8, g'8, g'2")])
\end{minted}
\begin{minted}{python}
>>> inspect_(staff).get_spanners()
set([Crescendo('<Staff{3}>')])
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Note above that the results of each inspection for spanner
attachments returns a set comprising a unique collection of spanners. Analogous
to component parents and children, each component can appear only once in a
single spanner's component selection, and a spanner can only be attached once
to the same component. Spanners can also be inspected -- much like containers
-- for any components they cover via indexing, as well as for their duration:

\begin{comment}
<abjad>
len(slur)
slur[1]
slur[:]
inspect_(slur).get_duration()
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> len(slur)
5
\end{minted}
\begin{minted}{python}
>>> slur[1]
Note("c'8")
\end{minted}
\begin{minted}{python}
>>> slur[:]
Selection(Note("c'4"), Note("c'8"), Note("e'8"), Note("g'8"), Note("g'2"))
\end{minted}
\begin{minted}{python}
>>> inspect_(slur).get_duration()
Duration(1, 1)
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Note that subscripting the spanner with Python's slice notation
\texttt{[:]} returns a \emph{selection} object containing all of the components
to which the spanner attaches. The role of selections is discussed in more
detail in \autoref{sec:selecting-components}.

Returning to the graph visualizations of score trees demonstrated
earlier will clarify how spanners attach to components. Consider the following
new staff, containing two measures of differing durations, each containing a
mixture of tuplets and notes. The second measure's tuplet contains two bare
containers, each containing two notes in turn. The leaves of the staff then
vary in depth from 2 -- contained by a measure, then by the staff -- to 4 --
contained by a bare container, then a tuplet, a measure and finally the staff:

\begin{comment}
<abjad>
staff = Staff()
measure_one = Measure((3, 4), r"c'4 \times 2/3 { d'4 e'4 f'4 }")
measure_two = Measure((4, 4), r"\times 3/4 { { g'4 a'4 } { b'4 c''4 } } c'4")
staff.extend([measure_one, measure_two])
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> staff = Staff()
>>> measure_one = Measure((3, 4), r"c'4 \times 2/3 { d'4 e'4 f'4 }")
>>> measure_two = Measure((4, 4), r"\times 3/4 { { g'4 a'4 } { b'4 c''4 } } c'4")
>>> staff.extend([measure_one, measure_two])
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-1396462d8b9df3f509b6050313eda7f6.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The staff's score hierarchy can be visualized as a graph with the
leaves arranged at the bottom and grouped together according to their depth:

\begin{comment}
<abjad>
graph(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> graph(staff)
\end{minted}
\noindent\includegraphics[scale=0.4,max width=\textwidth,]{assets/graphviz-9dcf1f7f32dcf3f7c356825ed86cdb3a.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent A \texttt{Spanner} can be attached to the leaves of the staff. Note
that while all spanners' structural behavior is identical to that of their
parent \texttt{Spanner} class, \texttt{Spanner} itself provides no formatting
beyond the optional typographic overrides discussed in
\autoref{sec:typographic-overrides}, so there is no need to illustrate the
newly-altered staff as notation. However, the staff can be graphed again, this
time highlighting and connecting together the nodes in the graph representing
the components to which the spanner attaches by passing that spanner as a
keyword to \texttt{graph()}:\footnote{Abjad relies on the open-source Graphviz
toolkit to visualize graph structures. Abjad also provides an object-oriented
model of Graphviz's input file format as part of its
\texttt{documentationtools} subpackage. There are many layout options available
when working with Graphviz, and they can be passed as keywords to Abjad's
top-level \texttt{graph()} function, hence the appearance of the
\texttt{graph\_attributes} keyword. These overrides are necessary to circumvent
deficiencies in Graphviz's handling of this particular graph's layout.}

\begin{comment}
<abjad>
spanner = spannertools.Spanner()
attach(spanner, staff.select_leaves())
graph(staff, spanner=spanner, graph_attributes={
    'splines': 'curved',
    'concentrate': True,
    })
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> spanner = spannertools.Spanner()
>>> attach(spanner, staff.select_leaves())
>>> graph(staff, spanner=spanner, graph_attributes={
...     'splines': 'curved',
...     'concentrate': True,
...     })
\end{minted}
\noindent\includegraphics[scale=0.4,max width=\textwidth,]{assets/graphviz-5ab2e467e47fcf944bc4a42613ee38c2.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The spanner can be detached from the staff's leaves and reattached to
the staff itself. Recall that spanners can attach to one or more of any
combination of containers and leaves, provided all are contiguous in time and
occupy the same logical voice. Note in the following graph that the node
representing the staff is both outlined in bold and shaded grey while all of
the components underneath it in the score hierarchy are simply shaded grey. In
these score hierarchy graphs, only those nodes to which the spanner directly
attaches are outlined in bold, while all components that the spanner
covers are simply shaded:

\begin{comment}
<abjad>
detach(spanner)
attach(spanner, staff)
graph(staff, spanner=spanner)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> detach(spanner)
>>> attach(spanner, staff)
>>> graph(staff, spanner=spanner)
\end{minted}
\noindent\includegraphics[scale=0.4,max width=\textwidth,]{assets/graphviz-a5232415348a30adb6c49f9fa588192b.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The spanner can then be detached from the staff and attached to the
two measures it contains:

\begin{comment}
<abjad>
detach(spanner)
attach(spanner, staff[:])
graph(staff, spanner=spanner)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> detach(spanner)
>>> attach(spanner, staff[:])
>>> graph(staff, spanner=spanner)
\end{minted}
\noindent\includegraphics[scale=0.4,max width=\textwidth,]{assets/graphviz-145928dc76cbac819d962e7dca54e95f.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The spanner can also be detached again and reattached to a selection
created by selecting the contents of both measures and concatenating those
selections together. Note that the spanner's components -- those nodes outlined
in bold and connected by bold arrows -- here comprise both leaves and
containers, but outline the same collection of leaves as the previous graphs:

\begin{comment}
<abjad>
detach(spanner)
attach(spanner, measure_one[:] + measure_two[:])
graph(staff, spanner=spanner)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> detach(spanner)
>>> attach(spanner, measure_one[:] + measure_two[:])
>>> graph(staff, spanner=spanner)
\end{minted}
\noindent\includegraphics[scale=0.4,max width=\textwidth,]{assets/graphviz-128d6bb41295ccd3c0fa73737de67f68.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Finally, the spanner can be detached from the previous selection and
reattached to a new selection comprising the concatenated contents of each
measures' tuplet child:

\begin{comment}
<abjad>
detach(spanner)
attach(spanner, measure_one[1][:] + measure_two[0][:])
graph(staff, spanner=spanner)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> detach(spanner)
>>> attach(spanner, measure_one[1][:] + measure_two[0][:])
>>> graph(staff, spanner=spanner)
\end{minted}
\noindent\includegraphics[scale=0.4,max width=\textwidth,]{assets/graphviz-d66575f5214655347456300f5b02fdb8.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Yet despite being attachable to both containers and leaves, spanners
only contribute formatting to the leaves they cover, not to any container. Why
attach spanners to containers at all? Any spanner attached to a container will
contribute formatting to the leaves of that container, regardless of what those
leaves are, and even if they change during the course of composition. Consider
the following small staff example, containing four notes, with the inner two
notes wrapped in a bare container:

\begin{comment}
<abjad>
staff = Staff("c'4 { d'4 e'4 } f'4")
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> staff = Staff("c'4 { d'4 e'4 } f'4")
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-dbe491cfd83502c93e6814ad5d741196.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent After attaching a slur to the inner container, the slur appears in
the notational output, starting on the first leaf of the inner container and
stopping on the last leaf:

\begin{comment}
<abjad>
attach(Slur(), staff[1])
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> attach(Slur(), staff[1])
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-3daaa77ec313b89c65a0b8e4a16a1e0a.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent More leaves can be inserted into the inner container, both before,
between and after the original two notes. The slur still appears starting on
the first leaf of the inner container and continuing until its last, although
both have changed from the original two notes:

\begin{comment}
<abjad>
staff[1].insert(1, "ef'4")
staff[1].insert(0, "af'4")
staff[1].extend("f'4 g'4")
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> staff[1].insert(1, "ef'4")
>>> staff[1].insert(0, "af'4")
>>> staff[1].extend("f'4 g'4")
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-4abb62417034edc341ce0058971c9e03.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The inner container can be emptied completely, at which point the
slur no longer appears in any notational output. However, inspecting the inner
container's inventory of spanners shows that the slur is still attached:

\begin{comment}
<abjad>
staff[1][:] = []
print(format(staff))
show(staff)
inspect_(staff[1]).get_spanners()
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> staff[1][:] = []
>>> print(format(staff))
\new Staff {
    c'4
    {
    }
    f'4
}
\end{minted}
\begin{minted}{python}
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-6b96d2995f7bab01a7332070cee299f3.pdf}
\begin{minted}{python}
>>> inspect_(staff[1]).get_spanners()
set([Slur('Container()')])
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Finally, the inner container can be repopulated, allowing the slur to
appear again:

\begin{comment}
<abjad>
staff[1].extend("e'4 d'4")
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> staff[1].extend("e'4 d'4")
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-ba0ca426f34264f0b15ca6d8d93aa94d.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Attaching spanners to containers rather than leaves lets spanners act
as a kind of \emph{decorator}\cite{gamma1994design} for those containers in the
sense of computer programming design patterns: an object which wraps another
object, extending it with new functionality while preserving all of the old. In
this case, spanners can extend containers with additional typographic logic,
but remain entirely ignorant of the container's contents.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Typographic overrides}
\label{sec:typographic-overrides}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

LilyPond's graphic objects, or \emph{grobs} in LilyPond parlance, represent all
of the typographic glyphs which may appear on the page as the result of the
typesetting process. These include note-heads, dots, stems, flags, beams,
slurs, accidentals, articulations, clefs, bar-numbers and bar-lines, the lines
of the staff itself, as well as all manner of \emph{invisible} grobs used
to describe the spacing and positioning of other glyphs on the page. Every such
grob in LilyPond can be configured extensively. An accidental's color can be
changed, its size increased or decreased, its position relative to its parent
grob -- the note-head it modifies -- adjusted, or its symbol replaced entirely.
LilyPond calls the act of modifying graphic objects \emph{overriding}, and the
act of returning them to their previous settings \emph{reverting}. Abjad
provides a top-level \texttt{override()} function for constructing such
LilyPond \texttt{\textbackslash{}override} and \texttt{\textbackslash{}revert}
commands, allowing composers to alter the typography of individual leaves or
the contents of entire containers. For example, the style of a single note's
note-head can be changed from the default oval shape to a cross:

\begin{comment}
<abjad>
note = Note("c'4")
override(note).note_head.style = 'cross'
print(format(note))
show(note)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> note = Note("c'4")
>>> override(note).note_head.style = 'cross'
>>> print(format(note))
\once \override NoteHead #'style = #'cross
c'4
\end{minted}
\begin{minted}{python}
>>> show(note)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-440c9c49d229a9b665fb9729ca57ce6d.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent In the resulting LilyPond code above, Abjad prepends a
\texttt{\textbackslash{}once} modifier to the override command, obviating the
need to explicitly revert the typography override afterward. The same override
can be applied against an entire container full of notes, modifying each note
in turn:

\begin{comment}
<abjad>
container = Container("c'4 d'4 e'4 f'4")
override(container).note_head.style = 'cross'
print(format(container))
show(container)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> container = Container("c'4 d'4 e'4 f'4")
>>> override(container).note_head.style = 'cross'
>>> print(format(container))
{
    \override NoteHead #'style = #'cross
    c'4
    d'4
    e'4
    f'4
    \revert NoteHead #'style
}
\end{minted}
\begin{minted}{python}
>>> show(container)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-6241a916ef5cd76a7cf9074e4b011d45.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Note above in the LilyPond syntax output that the override command
appears just inside the opening brace of the container, and the accompanying
revert command appears just before the closing brace. Much like the earlier
spanner examples where a slur was attached directly to a container, overrides
applied against a container persist regardless of the contents of that
container.

As with score components, composers can also apply typographic overrides
against spanners. The initial override commands appears before the first leaf
of the spanner -- if the spanner covers any leaves at all -- and the
accompanying revert commands appear following the last leaf of the spanner.
Consider the following staff example, containing three measures, with staccato
articulations attached to each leaf:

\begin{comment}
<abjad>
staff = Staff()
staff.append(Measure((3, 4), "c'4 d' r"))
staff.append(Measure((5, 4), r"e'4 \times 2/3 { f' g' r4 } a' b"))
staff.append(Measure((2, 4), "c''8 g' c'4"))
articulation = Articulation('staccato')
for leaf in staff.select_leaves():
    if isinstance(leaf, Note):
        attach(articulation, leaf)

show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> staff = Staff()
>>> staff.append(Measure((3, 4), "c'4 d' r"))
>>> staff.append(Measure((5, 4), r"e'4 \times 2/3 { f' g' r4 } a' b"))
>>> staff.append(Measure((2, 4), "c''8 g' c'4"))
>>> articulation = Articulation('staccato')
>>> for leaf in staff.select_leaves():
...     if isinstance(leaf, Note):
...         attach(articulation, leaf)
...
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-335fabac755e9f43c6612175f46e41d0.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent We can override the middle measure to increase the size of the
staccato articulations -- what LilyPond terms \emph{scripts} -- by increasing
their font size:

\begin{comment}
<abjad>
override(staff[1]).script.font_size = 10
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> override(staff[1]).script.font_size = 10
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-159a2f0600d4bc7482fa8d8b96f72e41.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Next we attach a slur to all leaves starting from the second and
going until the next-to-last. We also override that slur to change the style of
the note head of each note and chord it covers from the default oval to a
cross. Recall that spanners can cross different levels of hierarchy in the
score tree. Likewise, typographic overrides applied against spanners also
cross container boundaries such as the three measures contained within this
staff:

\begin{comment}
<abjad>
slur = spannertools.Slur(direction=Down)
attach(slur, staff.select_leaves()[1:-1])
override(slur).note_head.style = 'cross'
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> slur = spannertools.Slur(direction=Down)
>>> attach(slur, staff.select_leaves()[1:-1])
>>> override(slur).note_head.style = 'cross'
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-ca02eccb3e94b5f77d471649cca62c70.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Note the locations of the \texttt{\textbackslash{}override} and
\texttt{\textbackslash{}revert} commands for both the spanner and the middle
measure in the LilyPond syntax output. While the middle measure's
\texttt{\textbackslash{}override} and \texttt{\textbackslash{}revert} commands
appear just within its enclosing braces, the slur's
\texttt{\textbackslash{}override} command appears just before its first leaf --
the D quarter-note -- and its \texttt{\textbackslash{}revert} command just
after its last leaf -- the G eighth-note:

\begin{comment}
<abjad>
print(format(staff))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> print(format(staff))
\new Staff {
    {
        \time 3/4
        c'4 -\staccato
        \override NoteHead #'style = #'cross
        d'4 -\staccato _ (
        r4
    }
    {
        \override Script #'font-size = #10
        \time 5/4
        e'4 -\staccato
        \times 2/3 {
            f'4 -\staccato
            g'4 -\staccato
            r4
        }
        a'4 -\staccato
        b4 -\staccato
        \revert Script #'font-size
    }
    {
        \time 2/4
        c''8 -\staccato
        g'8 -\staccato )
        \revert NoteHead #'style
        c'4 -\staccato
    }
}
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The typographic overrides of both the slur and the middle measure
persist even when changing the contents of that middle measure, such as
replacing the triplet with four eighth-notes:

\begin{comment}
<abjad>
staff[1][1:2] = "f'8 -. g'8 -. fs'8 -. g'8 -."
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> staff[1][1:2] = "f'8 -. g'8 -. fs'8 -. g'8 -."
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-b9f0b722e88c76a69e3c1f0dd42dfd94.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Typographic overrides \emph{cascade}, with local settings taking
precedence over more global settings. Although the previously attached slur
overrides the note-head style of all leaves it covers, the note-head styles of
leaves within that collection can be overridden themselves. For example, the
first, last and next-to-last leaf of the middle measure can be overridden to
display a slash symbol rather than cross for their note-heads, effectively
overruling the more global typographic commands applied against their covering
spanner:

\begin{comment}
<abjad>
for index in (0, -2, -1):
    override(staff[1][index]).note_head.style = 'slash'

show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> for index in (0, -2, -1):
...     override(staff[1][index]).note_head.style = 'slash'
...
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-2b17b587265cfc4bae3ef8ddc8440459.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\todo[inline]{\textbf{TODO:} Conclusion of typography discussion.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Selecting components}
\label{sec:selecting-components}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Abjad provides a variety of methods for selecting components from within a
score tree. A number of these techniques have already been demonstrated. For
example, a score can be subscripted with integers or integer \emph{slices} --
e.g. \texttt{[1:-1]} -- representing the indices of some component or
components to select those component, as shown in \autoref{ssec:containers}
and later. Similarly, named components can be selected from a score by
subscripting that score with their names, as shown in
\autoref{ssec:named-components}. The leaves at the bottom of a score hierarchy
can also be selected en masse via a component's \texttt{select\_leaves()}
method regardless of their depth within the tree, also shown in
\autoref{ssec:containers}. All of these techniques represent \emph{component
selection}.

Abjad object-models the concept of component selection explicitly with its
\texttt{Selection} class. Selections allow arbitrary collection of components
to be grouped together and inspected without altering the score tree in the act
of selecting. Unlike containers or spanner, components grouped by a selection
have no reference back to that selection. Such unidirectional references
prevent considerable complexity in the system and allow selections to be made
and discarded with ease. However, like containers, spanners and the component
inspector, selections expose a variety of methods for examining the components
they group. Consider the following staff, which contains a variety of spanners
attached to its leaves:

\begin{comment}
<abjad>
staff = Staff("c'8 ( [ d' e' f '] g' [ a' b' c'' ) ]")
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> staff = Staff("c'8 ( [ d' e' f '] g' [ a' b' c'' ) ]")
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-dddf9b4ce50a2501abcd845f887a68dc.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent A selection can be made simply by subscripting the staff to select
from the third leaf until the seventh:

\begin{comment}
<abjad>
selection = staff[2:6]
print(format(selection))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> selection = staff[2:6]
>>> print(format(selection))
selectiontools.SliceSelection(
    (
        scoretools.Note("e'8"),
        scoretools.Note("f'8 ]"),
        scoretools.Note("g'8 ["),
        scoretools.Note("a'8"),
        )
    )
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent That selection can be iterated over like a list, and inspected for
its total duration and timespan -- its start and stop offsets, discussed at
length in \autoref{chap:time-tools}:

\begin{comment}
<abjad>
for component in selection:
    component

selection.get_duration()
selection.get_timespan()
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> for component in selection:
...     component
...
Note("e'8")
Note("f'8")
Note("g'8")
Note("a'8")
\end{minted}
\begin{minted}{python}
>>> selection.get_duration()
Duration(1, 2)
\end{minted}
\begin{minted}{python}
>>> selection.get_timespan()
Timespan(start_offset=Offset(1, 4), stop_offset=Offset(3, 4))
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Furthermore, the selection can be passed as the target to which a
spanner attaches. Recall the use of subscripts in calls to \texttt{attach()} in
\autoref{sec:spanners}. All of those container subscripting expressions
produced selection objects, although they were not displayed on the console at
any point. In this case, we can attach a glissando spanner to the leaf
selection:

\begin{comment}
<abjad>
attach(Glissando(), selection)
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> attach(Glissando(), selection)
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-e0be400f6a1d03dba850f9aec84b0885.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Selections can also be queried for the spanners covering the
components they contain:

\begin{comment}
<abjad>
for spanner in selection.get_spanners():
    spanner

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> for spanner in selection.get_spanners():
...     spanner
...
Slur("c'8, d'8, e'8, f'8, g'8, a'8, b'8, c''8")
Beam("g'8, a'8, b'8, c''8")
Beam("c'8, d'8, e'8, f'8")
Glissando("e'8, f'8, g'8, a'8")
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Logical ties}
\label{ssec:logical-ties}

Abjad provides a number of selection subclasses, some of which have already
been described. For example, the \texttt{Parentage} class, discussed in
\autoref{ssec:parentage} is actually a type of selection, and affords the same
methods described above in addition to many others. One of the most fundamental
selection subclasses in Abjad is the \texttt{LogicalTie}. Logical ties -- which
are distinct from tie \emph{spanners} -- model the concept of one or more note
or chord tied together to create a single attack point with an aggregate
duration. Logical ties containing a single note or chord are termed
\emph{trivial}. Logical ties comprising rests are not well-defined, but can
certainly be instantiated like any other selection if a composer would find
them useful.

Consider the following staff, which contains a mixture of notes and rests. The
\texttt{~} symbol in LilyPond syntax indicates that two notes should be joined
by a tie. Notably, this staff contains notes which are untied, notes which are
tied to a single other note, a chain of three notes tied together, and ties
which cross the bounds of a triplet:

\begin{comment}
<abjad>
staff = Staff(context_name='RhythmicStaff')
staff.extend(r"c'4 r4.. c'16 ~ c'4 ~ \times 2/3 { c'8 r4 c'8 ~ } c'4 r4 c'4")
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> staff = Staff(context_name='RhythmicStaff')
>>> staff.extend(r"c'4 r4.. c'16 ~ c'4 ~ \times 2/3 { c'8 r4 c'8 ~ } c'4 r4 c'4")
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-ba551cbad06ff7c663324b7234592b52.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The most direct way to select a leaf's logical tie is via the
component inspector's \texttt{.get\_logical\_tie()} method. Once selected, the
logical tie can be examined or printed much like any other selection:

\begin{comment}
<abjad>
logical_tie = inspect_(staff[2]).get_logical_tie()
print(format(logical_tie))
logical_tie.get_duration()
logical_tie.get_timespan()
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> logical_tie = inspect_(staff[2]).get_logical_tie()
>>> print(format(logical_tie))
selectiontools.LogicalTie(
    (
        scoretools.Note("c'16 ~"),
        scoretools.Note("c'4 ~"),
        scoretools.Note("c'8"),
        )
    )
\end{minted}
\begin{minted}{python}
>>> logical_tie.get_duration()
Duration(19, 48)
\end{minted}
\begin{minted}{python}
>>> logical_tie.get_timespan()
Timespan(start_offset=Offset(11, 16), stop_offset=Offset(13, 12))
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Like \texttt{Parentage}, logical tie selections expose properties
which are specific to their domain. Two of the most important such properties
are a logical tie's \emph{head} and \emph{tail}: the first and last leaves of
the logical tie respectively. We can label the previously selected logical
tie's head and tail with markup:

\begin{comment}
<abjad>
logical_tie.head
logical_tie.tail
head_markup = Markup('head', direction=Up)
head_markup = head_markup.pad_around(0.5).box().pad_around(0.5)
tail_markup = Markup('tail', direction=Up)
tail_markup = tail_markup.pad_around(0.5).box().pad_around(0.5)
attach(head_markup, logical_tie.head)
attach(tail_markup, logical_tie.tail)
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> logical_tie.head
Note("c'16")
\end{minted}
\begin{minted}{python}
>>> logical_tie.tail
Note("c'8")
\end{minted}
\begin{minted}{python}
>>> head_markup = Markup('head', direction=Up)
>>> head_markup = head_markup.pad_around(0.5).box().pad_around(0.5)
>>> tail_markup = Markup('tail', direction=Up)
>>> tail_markup = tail_markup.pad_around(0.5).box().pad_around(0.5)
>>> attach(head_markup, logical_tie.head)
>>> attach(tail_markup, logical_tie.tail)
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-ddb6d6aef18eee596f5e7f9198af1bf0.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Logical ties expose other pertinent properties. For example, a
logical tie can be queried for whether all of its leaves occupy the same
parent, whether none of its leaves are rests -- therefore the logical tie is
pitched --, or whether the logical tie is trivial:

\begin{comment}
<abjad>
logical_tie.all_leaves_are_in_same_parent
logical_tie.is_pitched
logical_tie.is_trivial
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> logical_tie.all_leaves_are_in_same_parent
False
\end{minted}
\begin{minted}{python}
>>> logical_tie.is_pitched
True
\end{minted}
\begin{minted}{python}
>>> logical_tie.is_trivial
False
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Trivial logical ties can also be selected. For example, the first
leaf in the above staff is covered by no tie spanner at all. Still, that leaf
can be modeled as a logical tie containing only a single note. A trivial
logical tie's head and tail are then the same component:

\begin{comment}
<abjad>
trivial_logical_tie = inspect_(staff[0]).get_logical_tie()
trivial_logical_tie.is_trivial
print(format(trivial_logical_tie))
attach(head_markup, trivial_logical_tie.head)
attach(tail_markup, trivial_logical_tie.tail)
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> trivial_logical_tie = inspect_(staff[0]).get_logical_tie()
>>> trivial_logical_tie.is_trivial
True
\end{minted}
\begin{minted}{python}
>>> print(format(trivial_logical_tie))
selectiontools.LogicalTie(
    (
        scoretools.Note("c'4"),
        )
    )
\end{minted}
\begin{minted}{python}
>>> attach(head_markup, trivial_logical_tie.head)
>>> attach(tail_markup, trivial_logical_tie.tail)
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-7d4426baa6f644c9ba82357b0f8dcfe1.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent

\subsection{Iteration}
\label{ssec:iteration}

Abjad provides a variety of techniques for iterating over the components in a
score tree.

\begin{comment}
<abjad>
show(score)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> show(score)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-c5f77f1a94704e8f098e761bd215d443.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The \enquote{simplest} iteration technique employed in Abjad relies
on Python's \emph{iteration protocol}, which allows objects to be iterated over
in \texttt{for} loops -- and many other constructs -- yielding up items from
their contents one at a time:

\begin{comment}
<abjad>
for x in ['foo', 10, 3.14159]:
    x

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> for x in ['foo', 10, 3.14159]:
...     x
...
'foo'
10
3.14159
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Using this basic iteration, the components immediately contained by
any Abjad container can be iterated over as though that container were a list.
For example, the components immediately contained in the score, the score's
staff group and the voice contained in the upper staff can be iterated over:

\begin{comment}
<abjad>
for component in score:
    component

for component in score['Both Staves']:
    component

for component in score['Voice 1']:
    component

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> for component in score:
...     component
...
<PianoStaff-"Both Staves"<<2>>>
\end{minted}
\begin{minted}{python}
>>> for component in score['Both Staves']:
...     component
...
<Staff-"Upper Staff"{1}>
<Staff-"Lower Staff"{1}>
\end{minted}
\begin{minted}{python}
>>> for component in score['Voice 1']:
...     component
...
Measure((3, 4), "d'4.. b'16 af'4")
Measure((5, 4), "af'4. g'8 c''8 b'4. b'8 r16 d''16")
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Abjad also provides an \emph{iteration agent} -- much like Abjad's
component inspector -- which exposes a variety of iteration methods. Calling
the top-level \texttt{iterate()} function against a score component returns an
iteration agent configured to iterate over the contents of that component:

\begin{comment}
<abjad>
iteration_agent = iterate(score)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> iteration_agent = iterate(score)
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Perhaps the most fundamental method of score tree traversal is
\emph{depth-first iteration}\cite{cormen2009introduction} whereby not only is a
given container iterated over but each container it contains as well and each
container those contain, recursively down to the leaves of the score tree. The
iteration agent exposes depth first traversal via a method call. We can
demonstrate this traversal algorithm by inspecting the parentage of each score
component yielded during each step of the traversal process and printing them
to the terminal indented by their \enquote{depth} relative to the root of the
score tree:

\begin{comment}
<abjad>
for component in iteration_agent.depth_first():
    parentage = inspect_(component).get_parentage()
    component_depth = parentage.depth
    indent = '    ' * component_depth
    string = '{}{}'.format(indent, repr(component))
    print(string)

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> for component in iteration_agent.depth_first():
...     parentage = inspect_(component).get_parentage()
...     component_depth = parentage.depth
...     indent = '    ' * component_depth
...     string = '{}{}'.format(indent, repr(component))
...     print(string)
...
<Score<<1>>>
    <PianoStaff-"Both Staves"<<2>>>
        <Staff-"Upper Staff"{1}>
            <Voice-"Voice 1"{2}>
                Measure((3, 4), "d'4.. b'16 af'4")
                    Note("d'4..")
                    Note("b'16")
                    Note("af'4")
                Measure((5, 4), "af'4. g'8 c''8 b'4. b'8 r16 d''16")
                    Note("af'4.")
                    Note("g'8")
                    Note("c''8")
                    Note("b'4.")
                    Note("b'8")
                    Rest('r16')
                    Note("d''16")
        <Staff-"Lower Staff"{1}>
            <Voice-"Voice 2"{2}>
                Measure((3, 4), "r8 c'8 r8 d8 r8 e8")
                    Rest('r8')
                    Note("c'8")
                    Rest('r8')
                    Note('d8')
                    Rest('r8')
                    Note('e8')
                Measure((5, 4), 'r4 { 2/3 g4 fs4 e8 cs8 } r4. fs8')
                    Rest('r4')
                    Tuplet(Multiplier(2, 3), 'g4 fs4 e8 cs8')
                        Note('g4')
                        Note('fs4')
                        Note('e8')
                        Note('cs8')
                    Rest('r4.')
                    Note('fs8')
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Note how the above indented output mirrors the graph visualization of
the same score tree, with the indent of each components representation
corresponding to the number of edges between that component and the score
tree's root score container:

\begin{comment}
<abjad>
graph(score)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> graph(score)
\end{minted}
\noindent\includegraphics[scale=0.4,max width=\textwidth,]{assets/graphviz-cd4e4715fc44715a6b9884dff43b2b03.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent In fact, Abjad's score tree graph visualizations, like many of the
other more-specialized score tree iteration techniques including the
\texttt{select\_leaves()} method shown throughout this document, rely on this
depth-first traversal. One of the most common iteration techniques based
closely on depth-first traversal is iteration by class, whereby a score tree is
iterated over recursively and only those items matching a component class
prototype -- e.g. only rests, only tuplets, only notes and chords, or any type
of leaf -- are yielded. We can demonstrate this technique by iterating over the
same score by rests and attaching some markup to each yielded rest:

\begin{comment}
<abjad>
iterator = iteration_agent.by_class(Rest)
for count, rest in enumerate(iterator, start=1):
    string = 'R:{}'.format(count)
    markup = Markup(string, direction=Up)
    markup = markup.pad_around(0.5).box().pad_around(0.25)
    attach(markup, rest)

show(score)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> iterator = iteration_agent.by_class(Rest)
>>> for count, rest in enumerate(iterator, start=1):
...     string = 'R:{}'.format(count)
...     markup = Markup(string, direction=Up)
...     markup = markup.pad_around(0.5).box().pad_around(0.25)
...     attach(markup, rest)
...
>>> show(score)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-da3c33d6146317b6564053525185a185.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Note how the attached markup orders rests from left-to-right,
starting in the upper staff and then proceeding to the lower staff. Such a
traversal mirrors the order in which those rests appear during depth-first
traversal. Now, before proceeding to a demonstration of the next technique, we
first iterate over all of the components in the score tree depth-first and
detach any markup previously attached, such as the rest-numbering markup
attached above:

\begin{comment}
<abjad>
for component in iteration_agent.depth_first():
    detached = detach(Markup, component)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> for component in iteration_agent.depth_first():
...     detached = detach(Markup, component)
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Iteration by \emph{timeline} is another important score traversal
technique, yielding each component -- optionally filtered by a class prototype
-- in the order in which they in time relative to the start of the score.
Components with identical start times are yielded according to their score
index -- a tuple of indices describing the index of each of the components in a
component's parentage in \emph{their} parents. We can demonstrate this
iteration technique by iterating over all of the leaves in time-wise order,
attaching markup to display their index in the timeline:

\begin{comment}
<abjad>
iterator = iteration_agent.by_timeline(scoretools.Leaf)
for count, leaf in enumerate(iterator, 1):
    string = 'T:{}'.format(count)
    markup = Markup(string, direction=Up)
    markup = markup.pad_around(0.5).box().pad_around(0.25)
    attach(markup, leaf)

show(score)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> iterator = iteration_agent.by_timeline(scoretools.Leaf)
>>> for count, leaf in enumerate(iterator, 1):
...     string = 'T:{}'.format(count)
...     markup = Markup(string, direction=Up)
...     markup = markup.pad_around(0.5).box().pad_around(0.25)
...     attach(markup, leaf)
...
>>> show(score)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-db611b2a9376ffa7996eb179aa7fe64b.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Composers are often concerned with contiguous \emph{runs} of notes
and chords rather than any other collection of components Components can use
the iteration agent to iterate over components grouped contiguously by class:

\begin{comment}
<abjad>
lower_leaves = score['Voice 2'].select_leaves()
for run in iterate(lower_leaves).by_run(Note):
    run

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> lower_leaves = score['Voice 2'].select_leaves()
>>> for run in iterate(lower_leaves).by_run(Note):
...     run
...
(Note("c'8"),)
(Note('d8'),)
(Note('e8'),)
(Note('g4'), Note('fs4'), Note('e8'), Note('cs8'))
(Note('fs8'),)
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Finally, score trees can be traversed by logical ties -- selections
representing one or more component tied together by a tie spanner, as described
in \autoref{sec:selecting-components}. Before demonstrating this technique we
must both attach ties to some of the leaves in the upper staff -- the A-flats
and the Bs -- and strip out the previously-attached markup:

\begin{comment}
<abjad>
attach(Tie(), score['Upper Staff'].select_leaves()[2:4])
attach(Tie(), score['Upper Staff'].select_leaves()[6:8])
for component in iterate(score).depth_first():
    detached = detach(Markup, component)

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> attach(Tie(), score['Upper Staff'].select_leaves()[2:4])
>>> attach(Tie(), score['Upper Staff'].select_leaves()[6:8])
>>> for component in iterate(score).depth_first():
...     detached = detach(Markup, component)
...
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent With the score prepared, all pitched logical ties in the upper staff
can be iterated over and markup attached to the head of each:

\begin{comment}
<abjad>
upper_leaves = score['Voice 1'].select_leaves()
for logical_tie in iterate(upper_leaves).by_logical_tie(pitched=True):
    markup = Markup('H', direction=Up)
    markup = markup.pad_around(0.5).box()
    attach(markup, logical_tie.head)

show(score)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> upper_leaves = score['Voice 1'].select_leaves()
>>> for logical_tie in iterate(upper_leaves).by_logical_tie(pitched=True):
...     markup = Markup('H', direction=Up)
...     markup = markup.pad_around(0.5).box()
...     attach(markup, logical_tie.head)
...
>>> show(score)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-599627976e242fc860162eeef10e6e8c.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Selectors}
\label{ssec:selectors}

Component selectors are highly-configuration objects which object-model the act
of selecting components -- as demonstrated above -- by aggregating together a
series of small \emph{callback} classes into a \emph{pipeline}. Each callback
describes one step in the act of performing a complex selection, such as
selecting leaves, selecting logical ties, selecting the first item from a
selection, or selecting items whose length is longer than some count. Selectors
allow composers to model the procedure by which they, for example, select
rest-delimited runs of notes and chords, then select all logical ties within
those runs and finally select the last leaf of each logical tie, even if that
logical tie contains only a single leaf. Such a procedure, once codified in a
fully-configured selector, can be applied against any leaf, container or
selection of components.

When called against a component, an unconfigured selector simply selects that
component, returning the selection wrapped within a sequence so that the result
can be iterated over:

\begin{comment}
<abjad>
selector = selectortools.Selector()
for x in selector(score['Upper Staff']):
    x

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> selector = selectortools.Selector()
>>> for x in selector(score['Upper Staff']):
...     x
...
<Staff-"Upper Staff"{1}>
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The selector can be further configured by calling one of its various
generating methods. These methods duplicate the selector's current sequence of
callbacks and append a new one, returning a new selector containing the
modified callback sequence.\footnote{Selector configuration is conceptually
similar to the textual markup configuration used elsewhere in this chapter. In
both cases, the object can made to produce new, modified versions of itself
through the use of generative methods.} For example, the previously-created
selector can be configured to select the leaves in each selection it processes:

\begin{comment}
<abjad>
selector = selector.by_leaves(flatten=True)
for x in selector(score['Upper Staff']):
    x

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> selector = selector.by_leaves(flatten=True)
>>> for x in selector(score['Upper Staff']):
...     x
...
Note("d'4..")
Note("b'16")
Note("af'4")
Note("af'4.")
Note("g'8")
Note("c''8")
Note("b'4.")
Note("b'8")
Rest('r16')
Note("d''16")
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The selector's storage format shows its callback sequence. The leaf
selection callback appears here as a \texttt{PrototypeSelectorCallback}, itself
configured to select components of type \texttt{Leaf}:

\begin{comment}
<abjad>
print(format(selector))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> print(format(selector))
selectortools.Selector(
    callbacks=(
        selectortools.PrototypeSelectorCallback(
            prototype=scoretools.Leaf,
            flatten=True,
            ),
        ),
    )
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The selector can be configured to select all pitched logical-ties
from with the previous selections.

\begin{comment}
<abjad>
selector = selector.by_logical_tie(pitched=True)
for x in selector(score['Upper Staff']):
    x

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> selector = selector.by_logical_tie(pitched=True)
>>> for x in selector(score['Upper Staff']):
...     x
...
LogicalTie(Note("d'4.."),)
LogicalTie(Note("b'16"),)
LogicalTie(Note("af'4"), Note("af'4."))
LogicalTie(Note("g'8"),)
LogicalTie(Note("c''8"),)
LogicalTie(Note("b'4."), Note("b'8"))
LogicalTie(Note("d''16"),)
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Again, note the addition of a new callback to the selector's callback
pipeline:

\begin{comment}
<abjad>
print(format(selector))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> print(format(selector))
selectortools.Selector(
    callbacks=(
        selectortools.PrototypeSelectorCallback(
            prototype=scoretools.Leaf,
            flatten=True,
            ),
        selectortools.LogicalTieSelectorCallback(
            flatten=True,
            pitched=True,
            trivial=True,
            ),
        ),
    )
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The selector can be configured to filter out logical ties shorter
than a duration of \sfrac{1}{4}:

\begin{comment}
<abjad>
selector = selector.by_duration('>', Duration(1, 4))
for x in selector(score['Upper Staff']):
    x

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> selector = selector.by_duration('>', Duration(1, 4))
>>> for x in selector(score['Upper Staff']):
...     x
...
LogicalTie(Note("d'4.."),)
LogicalTie(Note("af'4"), Note("af'4."))
LogicalTie(Note("b'4."), Note("b'8"))
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The first item from each selected logical-tie can then be selected by
using Python's index subscripting syntax.

\begin{comment}
<abjad>
selector = selector[0]
for x in selector(score['Upper Staff']):
    print(repr(x))

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> selector = selector[0]
>>> for x in selector(score['Upper Staff']):
...     print(repr(x))
...
ContiguousSelection(Note("d'4.."),)
ContiguousSelection(Note("af'4"),)
ContiguousSelection(Note("b'4."),)
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Note that the returned selections each contain a single note. This is
not necessarily useful yet. By appending a single additional flattening
callback to the selector's callback stack, the selector can be configured to
return a flat selection of components which can be iterated over:

\begin{comment}
<abjad>
selector = selector.flatten()
for x in selector(score['Upper Staff']):
    print(repr(x))

</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> selector = selector.flatten()
>>> for x in selector(score['Upper Staff']):
...     print(repr(x))
...
Note("d'4..")
Note("af'4")
Note("b'4.")
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Unlike component iterators, selectors can be re-used. The same
selector which was called against the upper staff in the above example can be
called again, returning the same result. As with the examples in
\autoref{ssec:iteration}, we can label each component returned by the selector
with some markup. Because the score was already labeled -- marking the head of
each logical tie in the upper staff -- we first remove all markup by iterating
depth-first:

\begin{comment}
<abjad>
for component in iterate(score).depth_first():
    detached = detach(Markup, component)

markup = Markup('!!!', Up).pad_around(0.5).circle()
for x in selector(score['Upper Staff']):
    attach(markup, x)

show(score)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> for component in iterate(score).depth_first():
...     detached = detach(Markup, component)
...
>>> markup = Markup('!!!', Up).pad_around(0.5).circle()
>>> for x in selector(score['Upper Staff']):
...     attach(markup, x)
...
>>> show(score)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-8723021f627e4bd622582e3ceb453b8a.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Printing the storage format of the current selector shows its
deeply-nested configuration:

\begin{comment}
<abjad>
print(format(selector))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> print(format(selector))
selectortools.Selector(
    callbacks=(
        selectortools.PrototypeSelectorCallback(
            prototype=scoretools.Leaf,
            flatten=True,
            ),
        selectortools.LogicalTieSelectorCallback(
            flatten=True,
            pitched=True,
            trivial=True,
            ),
        selectortools.DurationSelectorCallback(
            duration=selectortools.DurationInequality(
                operator_string='>',
                duration=durationtools.Duration(1, 4),
                ),
            ),
        selectortools.ItemSelectorCallback(
            item=0,
            apply_to_each=True,
            ),
        selectortools.FlattenSelectorCallback(
            depth=-1,
            ),
        ),
    )
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Selectors are incredibly flexible. They allow composers to describe
in a great degree of detail the process they wish to use to select components
from a score for further transformation or ornamentation. As will be elaborated
on in the following chapters, they are also useful because they are fully
object-modeled as classes. Such object-modeling allows them to not only be used
to configure still-larger aggregate compositional objects, but also be
persisted to disk due to their well-formed storage format.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Templating \& persistence}
\label{sec:templating-and-persistence}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

One of the last, but most important aspects of working with Abjad does not
concern modeling notation at all. The act of \emph{templating} takes one object
and replaces the values assigned to one or more of its properties with new
values, returning a new object based on -- but differing from -- the old, while
the old object remains unchanged. Templating's combination of copying and
re-configuration is a standard concepts in computer science, but needs to be
introduced here due to its pervasive use throughout the rest of this document.

Recall the earlier \enquote{rhythm-maker} code example from
\autoref{sec:representing-objects}:

\begin{comment}
<abjad>
rhythm_maker = rhythmmakertools.TaleaRhythmMaker(
    talea=rhythmmakertools.Talea([1, 2, 3], 16),
    extra_counts_per_division=(1, 0, 2, 1, 0),
    output_masks=[
        rhythmmakertools.SustainMask([1], 3),
        rhythmmakertools.SilenceMask([-1]),
        rhythmmakertools.NullMask([0]),
        ],
    tie_specifier=rhythmmakertools.TieSpecifier(
        tie_across_divisions=True,
        ),
    )
print(format(rhythm_maker))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> rhythm_maker = rhythmmakertools.TaleaRhythmMaker(
...     talea=rhythmmakertools.Talea([1, 2, 3], 16),
...     extra_counts_per_division=(1, 0, 2, 1, 0),
...     output_masks=[
...         rhythmmakertools.SustainMask([1], 3),
...         rhythmmakertools.SilenceMask([-1]),
...         rhythmmakertools.NullMask([0]),
...         ],
...     tie_specifier=rhythmmakertools.TieSpecifier(
...         tie_across_divisions=True,
...         ),
...     )
>>> print(format(rhythm_maker))
rhythmmakertools.TaleaRhythmMaker(
    talea=rhythmmakertools.Talea(
        counts=(1, 2, 3),
        denominator=16,
        ),
    extra_counts_per_division=(1, 0, 2, 1, 0),
    output_masks=rhythmmakertools.BooleanPatternInventory(
        (
            rhythmmakertools.SustainMask(
                indices=(1,),
                invert=True,
                ),
            rhythmmakertools.SilenceMask(
                indices=(-1,),
                ),
            rhythmmakertools.NullMask(
                indices=(0,),
                ),
            )
        ),
    tie_specifier=rhythmmakertools.TieSpecifier(
        tie_across_divisions=True,
        ),
    )
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Without yet discussing the structure or purpose of this particular
object -- all of which is covered at length in \autoref{chap:time-tools} and
\autoref{chap:a-model-of-composition}, especially in
\autoref{sec:rhythm-makers} -- we can demonstrate Abjad's templating
functionality via its top-level \texttt{new()} function. For example,
\texttt{new()} can be used to template a new rhythm-maker from the old one shown
above, replacing the value referenced by one of its properties with a new
value. Here we replace its \texttt{extra\_counts\_per\_division} with the
sequence \texttt{[1, 2, 3]}. Note the change in the new rhythm-maker's storage
format:

\begin{comment}
<abjad>
new_rhythm_maker = new(rhythm_maker,
    extra_counts_per_division=[1, 2, 3],
    )
print(format(new_rhythm_maker))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> new_rhythm_maker = new(rhythm_maker,
...     extra_counts_per_division=[1, 2, 3],
...     )
>>> print(format(new_rhythm_maker))
rhythmmakertools.TaleaRhythmMaker(
    talea=rhythmmakertools.Talea(
        counts=(1, 2, 3),
        denominator=16,
        ),
    extra_counts_per_division=(1, 2, 3),
    output_masks=rhythmmakertools.BooleanPatternInventory(
        (
            rhythmmakertools.SustainMask(
                indices=(1,),
                invert=True,
                ),
            rhythmmakertools.SilenceMask(
                indices=(-1,),
                ),
            rhythmmakertools.NullMask(
                indices=(0,),
                ),
            )
        ),
    tie_specifier=rhythmmakertools.TieSpecifier(
        tie_across_divisions=True,
        ),
    )
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Multiple values can be replaced, and previously unspecified values
specified. Here we replace both the new rhythm-makers's \texttt{talea} and
\texttt{extra\_counts\_per\_division} values and specify a previously
unspecified \texttt{beam\_specifier}:

\begin{comment}
<abjad>
new_rhythm_maker = new(new_rhythm_maker,
    talea=rhythmmakertools.Talea([2, 1], 8),
    extra_counts_per_division=[1, 0, 1, 2, 0, 1],
    beam_specifier=rhythmmakertools.BeamSpecifier(
        beam_divisions_together=True,
        ),
    )
print(format(new_rhythm_maker))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> new_rhythm_maker = new(new_rhythm_maker,
...     talea=rhythmmakertools.Talea([2, 1], 8),
...     extra_counts_per_division=[1, 0, 1, 2, 0, 1],
...     beam_specifier=rhythmmakertools.BeamSpecifier(
...         beam_divisions_together=True,
...         ),
...     )
>>> print(format(new_rhythm_maker))
rhythmmakertools.TaleaRhythmMaker(
    talea=rhythmmakertools.Talea(
        counts=(2, 1),
        denominator=8,
        ),
    extra_counts_per_division=(1, 0, 1, 2, 0, 1),
    beam_specifier=rhythmmakertools.BeamSpecifier(
        beam_each_division=True,
        beam_divisions_together=True,
        use_feather_beams=False,
        ),
    output_masks=rhythmmakertools.BooleanPatternInventory(
        (
            rhythmmakertools.SustainMask(
                indices=(1,),
                invert=True,
                ),
            rhythmmakertools.SilenceMask(
                indices=(-1,),
                ),
            rhythmmakertools.NullMask(
                indices=(0,),
                ),
            )
        ),
    tie_specifier=rhythmmakertools.TieSpecifier(
        tie_across_divisions=True,
        ),
    )
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Arbitrarily-nested values can also be replaced by specifying names
delimited by double underscores. Here the denominator of the talea can be
reconfigured directly, changing it from the previous value of 8 to 4:

\begin{comment}
<abjad>
new_rhythm_maker = new(new_rhythm_maker,
    talea__denominator=4,
    )
print(format(new_rhythm_maker))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> new_rhythm_maker = new(new_rhythm_maker,
...     talea__denominator=4,
...     )
>>> print(format(new_rhythm_maker))
rhythmmakertools.TaleaRhythmMaker(
    talea=rhythmmakertools.Talea(
        counts=(2, 1),
        denominator=4,
        ),
    extra_counts_per_division=(1, 0, 1, 2, 0, 1),
    beam_specifier=rhythmmakertools.BeamSpecifier(
        beam_each_division=True,
        beam_divisions_together=True,
        use_feather_beams=False,
        ),
    output_masks=rhythmmakertools.BooleanPatternInventory(
        (
            rhythmmakertools.SustainMask(
                indices=(1,),
                invert=True,
                ),
            rhythmmakertools.SilenceMask(
                indices=(-1,),
                ),
            rhythmmakertools.NullMask(
                indices=(0,),
                ),
            )
        ),
    tie_specifier=rhythmmakertools.TieSpecifier(
        tie_across_divisions=True,
        ),
    )
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Storage formatting is used throughout Abjad and tools extending Abjad
for a number of reasons. For one, it provides a full description of a
potentially complex object's configuration in as human-readable a format as
possible. Storage formats are deterministic; any storage-formattable object
with a given configuration is guaranteed to format in one and only one way.
Non-trivial storage formats also take up multiple lines, making them
well-suited to line-based version control systems like Subversion, Git and
Mercurial -- among many others --. Most importantly, the storage format for any
storage-formattable object is guaranteed to be evaluable as code in Abjad's
namespace. Any object returned by evaluating another object's storage format as
a string will be configured identically to the original and compare equally.
This is a kind of human-readable \emph{serialization}. For example, the
selector created previously in \autoref{ssec:selectors} can be persisted via
its storage format and recreated by evaluating that storage format in Abjad's
namespace. The new selector compares equally to the old:

\begin{comment}
<abjad>
print(format(selector))
selector_format = format(selector)
evaluated_selector = eval(selector_format)
evaluated_selector == selector
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> print(format(selector))
selectortools.Selector(
    callbacks=(
        selectortools.PrototypeSelectorCallback(
            prototype=scoretools.Leaf,
            flatten=True,
            ),
        selectortools.LogicalTieSelectorCallback(
            flatten=True,
            pitched=True,
            trivial=True,
            ),
        selectortools.DurationSelectorCallback(
            duration=selectortools.DurationInequality(
                operator_string='>',
                duration=durationtools.Duration(1, 4),
                ),
            ),
        selectortools.ItemSelectorCallback(
            item=0,
            apply_to_each=True,
            ),
        selectortools.FlattenSelectorCallback(
            depth=-1,
            ),
        ),
    )
\end{minted}
\begin{minted}{python}
>>> selector_format = format(selector)
>>> evaluated_selector = eval(selector_format)
>>> evaluated_selector == selector
True
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Importantly, storage formatting affords persistence to disk. Abjad's
\emph{persistence agent} -- conceptually similar to the inspection agent,
iteration agent and others -- can write any storage-formattable object to disk
as an importable Python module, automatically including the appropriate library
import statements at the top of the file.

\begin{comment}
<abjad>
persistence_agent = persist(selector)
persistence_agent.as_module(
    module_file_path='a_selector_module.py',
    object_name='persisted_selector',
    )
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> persistence_agent = persist(selector)
>>> persistence_agent.as_module(
...     module_file_path='a_selector_module.py',
...     object_name='persisted_selector',
...     )
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The persisted module file can then be read. Note the various import
statements at the top -- \texttt{durationtools}, \texttt{scoretools},
\texttt{selectortools} -- which have been determined by introspecting the
selector:

\begin{comment}
<abjad>
with open('a_selector_module.py', 'r') as module_file_pointer:
    module_file_contents = module_file_pointer.read()

print(module_file_contents)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> with open('a_selector_module.py', 'r') as module_file_pointer:
...     module_file_contents = module_file_pointer.read()
...
>>> print(module_file_contents)
# -*- encoding: utf-8 -*-
from abjad.tools import durationtools
from abjad.tools import scoretools
from abjad.tools import selectortools


persisted_selector = selectortools.Selector(
    callbacks=(
        selectortools.PrototypeSelectorCallback(
            prototype=scoretools.Leaf,
            flatten=True,
            ),
        selectortools.LogicalTieSelectorCallback(
            flatten=True,
            pitched=True,
            trivial=True,
            ),
        selectortools.DurationSelectorCallback(
            duration=selectortools.DurationInequality(
                operator_string='>',
                duration=durationtools.Duration(1, 4),
                ),
            ),
        selectortools.ItemSelectorCallback(
            item=0,
            apply_to_each=True,
            ),
        selectortools.FlattenSelectorCallback(
            depth=-1,
            ),
        ),
    )
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The persisted selector can also be imported from the persisted
module, like any other importable Python code. It too compares equally to the
original selector:

\begin{comment}
<abjad>
from a_selector_module import persisted_selector
persisted_selector == selector
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> from a_selector_module import persisted_selector
>>> persisted_selector == selector
True
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Storage-formatting, templating and persistence are crucial for
working with Abjad at a high-level. Many of the compositionally-interesting
devices afforded by Abjad -- objects which describe compositional processes,
transformations, factories and the like -- involve a considerable amount of
configuration. Templating affords variation in these situations, allowing
composers to create new objects from old, varying a few or many aspects of the
object under consideration, but saving them from the work of having to define a
new object from scratch. Likewise, disk persistence allows composers to easily
save their work.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Other tools}
\label{sec:other-tools}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Abjad provides many other tools for working with notation and modeling musical
concepts, too many to discuss in full here. A wide variety of Abjad's classes
for modeling time, rhythm and meter are explored in \autoref{chap:time-tools},
along with various extensions implemented in the Consort composition-modeling
library, but others bear mentioning now.

\subsection{Mutation}
\label{ssec:mutation}

Abjad's \emph{mutation agent} -- similar again its inspection, iteration and
persistence agents -- affords techniques for \emph{destructively} transforming
already-instantiated score objects. Accessible via the top-level
\texttt{mutate()} function, the mutation agent can split, transpose and replace
components within a score. For example, the leaves in a score can be split
cyclically, every other split shard transposed by a minor-second, and slurs and
articulations attached to each shard:

\begin{comment}
<abjad>
staff = Staff("c'4 d'4 e'4 f'4 g'4 a'4 b'4 c''4")
agent = mutate(staff[:])
for i, shard in enumerate(agent.split(durations=[(3, 16)], cyclic=True)):
    if i % 2:
        mutate(shard).transpose('m2')
    if 1 < len(shard):
        attach(Slur(), shard)
    attach(Articulation('accent'), shard[0])

show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> staff = Staff("c'4 d'4 e'4 f'4 g'4 a'4 b'4 c''4")
>>> agent = mutate(staff[:])
>>> for i, shard in enumerate(agent.split(durations=[(3, 16)], cyclic=True)):
...     if i % 2:
...         mutate(shard).transpose('m2')
...     if 1 < len(shard):
...         attach(Slur(), shard)
...     attach(Articulation('accent'), shard[0])
...
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-6f46aed686dfd3fb345effde680cb782.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Pitch modeling}
\label{ssec:pitch-modeling}

Abjad provides a rich model of pitch, making explicit distinctions between
named pitches -- C4, Db5 -- and numbered pitches -- 0, 13 -- as well as
providing concrete models of named and numbered pitch-classes, intervals,
interval-classes, pitch-ranges, octaves, accidentals, and all manner of
specialized collection classes for these pitch objects, including pitch sets
and interval-class vectors, each with transformation methods pertinent to their
domain.

\begin{comment}
<abjad>
pitch_segment = pitchtools.PitchSegment("c' d' e' fs' gf'")
pitch_segment
pitch_segment = pitch_segment.rotate(1, transpose=True)
pitch_segment
pitch_segment[2].accidental
pitch_segment[2].octave
pitch_segment[2].named_pitch_class
pitchtools.IntervalSegment(pitch_segment)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> pitch_segment = pitchtools.PitchSegment("c' d' e' fs' gf'")
>>> pitch_segment
PitchSegment(["c'", "d'", "e'", "fs'", "gf'"])
\end{minted}
\begin{minted}{python}
>>> pitch_segment = pitch_segment.rotate(1, transpose=True)
>>> pitch_segment
PitchSegment(["c'", 'fs', 'gs', 'as', 'bs'])
\end{minted}
\begin{minted}{python}
>>> pitch_segment[2].accidental
Accidental('s')
\end{minted}
\begin{minted}{python}
>>> pitch_segment[2].octave
Octave(3)
\end{minted}
\begin{minted}{python}
>>> pitch_segment[2].named_pitch_class
NamedPitchClass('gs')
\end{minted}
\begin{minted}{python}
>>> pitchtools.IntervalSegment(pitch_segment)
IntervalSegment(['-dim5', '+M2', '+M2', '+M2'])
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Notably, Abjad's note-head objects -- aggregated into its notes and
chords -- always store their pitch information as named pitches, guaranteeing
an internal representation as close to the notational output as possible.

\subsection{Parsers}
\label{ssec:parsers}

Abjad comes equipped with a number of parsers. Most notably, Abjad implements a
parser for LilyPond's syntax, and can understand much -- although not all -- of
LilyPond's grammar. Any time a note, rest, chord, container or even textual
markup is instantiated with a string the LilyPond parser is at work. The
top-level \texttt{parse()} function provides access to the this parser:

\begin{comment}
<abjad>
string = r"\new Staff { c'4 ( \p \< d'4 e'4 f'4 ) \! }"
result = parse(string)
show(result)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> string = r"\new Staff { c'4 ( \p \< d'4 e'4 f'4 ) \! }"
>>> result = parse(string)
>>> show(result)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-50e654de74dec238b008efe1199ef153.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent The LilyPond parser can also be instantiated by hand and called:

\begin{comment}
<abjad>
string = r'''\new Staff { c' _ \markup { X \bold Y \italic Z "a b c" } }'''
parser = lilypondparsertools.LilyPondParser()
result = parser(string)
show(result)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> string = r'''\new Staff { c' _ \markup { X \bold Y \italic Z "a b c" } }'''
>>> parser = lilypondparsertools.LilyPondParser()
>>> result = parser(string)
>>> show(result)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-44e71792eef3cbc7354f535910ec43f0.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Abjad also implements a simple parser for RTM-like \emph{rhythm-tree}
syntax which parses strings into rhythm-tree objects which can then be
converted into proper tuplets:

\begin{comment}
<abjad>
rtm_parser = rhythmtreetools.RhythmTreeParser()
rtm_syntax = '(1 (1 (2 (1 -1 1)) -2))'
rtm_container = rtm_parser(rtm_syntax)[0]
abjad_container = rtm_container(Duration(1, 2))[0]
show(abjad_container)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> rtm_parser = rhythmtreetools.RhythmTreeParser()
>>> rtm_syntax = '(1 (1 (2 (1 -1 1)) -2))'
>>> rtm_container = rtm_parser(rtm_syntax)[0]
>>> abjad_container = rtm_container(Duration(1, 2))[0]
>>> show(abjad_container)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-900b83c24bcec6f313ced006914edcd7.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\subsection{Notation factories}
\label{ssec:notation-factories}

While composers can certainly create every object in a score by hand,
instantiating each note, chord or measure one-at-a-time, with experience, when
one is already working with notation computationally one tends to want means of
generating many score objects at once. Abjad provides a number of
\emph{factory} classes and functions for generating arbitrarily large amounts
of notation. The simplest such factory is the \texttt{scoretools.make\_notes()}
function, which combines sequences of pitches and durations in a patterned way
to create a selection of leaves:

\begin{comment}
<abjad>
pitches = ["c'", "ef'", "g'", 'b']
durations = [(3, 8), (5, 16), (1, 4)] * 3
notes = scoretools.make_notes(pitches, durations)
staff = Staff(notes)
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> pitches = ["c'", "ef'", "g'", 'b']
>>> durations = [(3, 8), (5, 16), (1, 4)] * 3
>>> notes = scoretools.make_notes(pitches, durations)
>>> staff = Staff(notes)
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-ac6a185fbc7ba752fa335cac4a95d031.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Abjad's \emph{rhythm-maker} family of classes -- discussed in depth
in \autoref{sec:rhythm-makers} -- provide a collection of highly-customizable
factories for generating rhythms:

\begin{comment}
<abjad>
rhythm_maker = rhythmmakertools.TaleaRhythmMaker(
    talea=rhythmmakertools.Talea(
        counts=[1, 2, 3, 4],
        denominator=16,
        ),
    tie_specifier=rhythmmakertools.TieSpecifier(
        tie_across_divisions=True,
        ),
    )
divisions = [(3, 8), (5, 8), (2, 8), (3, 8), (3, 8)]
rhythm = rhythm_maker(divisions)
staff = Staff(rhythm)
show(staff)
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> rhythm_maker = rhythmmakertools.TaleaRhythmMaker(
...     talea=rhythmmakertools.Talea(
...         counts=[1, 2, 3, 4],
...         denominator=16,
...         ),
...     tie_specifier=rhythmmakertools.TieSpecifier(
...         tie_across_divisions=True,
...         ),
...     )
>>> divisions = [(3, 8), (5, 8), (2, 8), (3, 8), (3, 8)]
>>> rhythm = rhythm_maker(divisions)
>>> staff = Staff(rhythm)
>>> show(staff)
\end{minted}
\noindent\includegraphics[max width=\textwidth,]{assets/lilypond-c8513549850b8c9e39824622dffe7198.pdf}
\end{singlespacing}
\end{abjadbookoutput}

\noindent Abjad's \emph{score template} classes act as factories for scores,
fully populated with voices, staves, staff groups, and potentially clefs and
instruments, but devoid of any \enquote{count-time} components -- notes, rests,
chords, tuplets or measures -- which comprise musical content. Score templates
play a large role in the work described in later chapters, especially
\autoref{chap:a-model-of-composition}, as they provide a way for multiple
score-generating processes to synchronize on a common score structure. For
example, \texttt{templatetools} provides a score template class for generating
string quartet scores:

\begin{comment}
<abjad>
score_template = templatetools.StringQuartetScoreTemplate()
score = score_template()
print(format(score))
</abjad>
\end{comment}

\begin{abjadbookoutput}
\begin{singlespacing}
\vspace{-0.5\baselineskip}
\begin{minted}{python}
>>> score_template = templatetools.StringQuartetScoreTemplate()
>>> score = score_template()
>>> print(format(score))
\context Score = "String Quartet Score" <<
    \context StaffGroup = "String Quartet Staff Group" <<
        \context Staff = "First Violin Staff" {
            \clef "treble"
            \set Staff.instrumentName = \markup { Violin }
            \set Staff.shortInstrumentName = \markup { Vn. }
            \context Voice = "First Violin Voice" {
            }
        }
        \context Staff = "Second Violin Staff" {
            \clef "treble"
            \set Staff.instrumentName = \markup { Violin }
            \set Staff.shortInstrumentName = \markup { Vn. }
            \context Voice = "Second Violin Voice" {
            }
        }
        \context Staff = "Viola Staff" {
            \clef "alto"
            \set Staff.instrumentName = \markup { Viola }
            \set Staff.shortInstrumentName = \markup { Va. }
            \context Voice = "Viola Voice" {
            }
        }
        \context Staff = "Cello Staff" {
            \clef "bass"
            \set Staff.instrumentName = \markup { Cello }
            \set Staff.shortInstrumentName = \markup { Vc. }
            \context Voice = "Cello Voice" {
            }
        }
    >>
>>
\end{minted}
\end{singlespacing}
\end{abjadbookoutput}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}
\label{ssec:a-model-of-notation-conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This chapter discussed the core components and concepts for working with
notation in Abjad. Composers aggregate score components, consisting of leaves
and containers, into nested, hierarchical score structures. Indicators and
spanners attach to the components in the tree, adding additional structuration,
annotation or typographic embellishment. Iteration and selection then provide
means for examining the constructed score tree, allowing composers to locate
components within the growing composition for examination, mutation or
decoration. The chapters that follow build on these techniques, and describe
increasingly high-level means of organizing time and generating notation en
masse with Abjad.